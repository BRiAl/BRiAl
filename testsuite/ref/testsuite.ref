Starting Testsuite...
---------------------
----------------------
Executing testsuite/idxtypes
----------------------
Testing CIdxPath, CIdx
Print list style: 
x(0), x(1), x(17), x(5), x(0)
Print monomial style: 
x(0)*x(1)*x(17)*x(5)*x(0)
Finished. 
----------------------
Executing testsuite/zddnavi
----------------------
Testing navigating through decision diagrams
poly:  
x(0)*x(2)*x(3)*x(4) + x(0)*x(2) + x(1) 
Navigation: 
x(0)*x(2)*x(3)*x(4) 
x(0)*x(2) 
x(1) 

Printing via dd_transform: 
x(0)*x(2)*x(3)*x(4) x(0)*x(2) x(1) 
Storing via dd_transform: 
0, 2, 3, 4, 
0, 2, 
1, 

pure print dd_transform: 
0 2 3 4 
0 2 
1 
0 2 3 4 , 0 2 , 1 , 

Get terms: 
x(0)*x(2)*x(3)*x(4) , x(0)*x(2) , x(1) , 

Test Term iteration 
x(0)*x(2)*x(3)*x(4) + x(0)*x(2)*x(4) + x(0)*x(2) + x(1) 
x(0)*x(2)*x(3)*x(4) 
x(0)*x(2)*x(4) 
x(0)*x(2) 
x(1) 
  last: 
0 
  next: 
x(0)*x(2)*x(3)*x(4) + x(0)*x(2)*x(4) + x(0)*x(2) + x(1) + 1 
1 
0 
  next: 
1 
1 
0 
  next: 
0 
0 
0 

Testing last term
poly x(0)*x(1) + x(0)*x(4) 
last term 0, 4, 

Testing last term
poly x(0)*x(1) + x(1)*x(4) 
last term 1, 4, 

Testing last term
poly x(0)*x(1) + x(2)*x(4) 
last term 2, 4, 

Testing last term
poly x(0)*x(1)*x(2)*x(3)*x(4) + x(2)*x(3)*x(4) + x(2)*x(4) 
last term 2, 4, 

Testing last term
poly x(0)*x(1)*x(2)*x(3)*x(4) + x(1)*x(2)*x(3)*x(4) + x(2)*x(3)*x(4) + x(2)*x(4) 
last term 2, 4, last term via BoolSet: x(2)*x(4) 

 Testing decrement...
poly x(0)*x(1)*x(2)*x(3)*x(4) + x(1)*x(2)*x(3)*x(4) + x(2)*x(3)*x(4) + x(2)*x(4) 
*iter x(0)*x(1)*x(2)*x(3)*x(4) 
++ 
*iter x(1)*x(2)*x(3)*x(4) 
++ 
*iter x(2)*x(3)*x(4) 
-- 
*iter x(1)*x(2)*x(3)*x(4) 
-- 
*iter x(0)*x(1)*x(2)*x(3)*x(4) 
++ 
*iter x(1)*x(2)*x(3)*x(4) 
++ 
*iter x(2)*x(3)*x(4) 
++ 
*iter x(2)*x(4) 
-- 
*iter x(2)*x(3)*x(4) 
-- 
*iter x(1)*x(2)*x(3)*x(4) 
-- 
*iter x(0)*x(1)*x(2)*x(3)*x(4) 
++ 
*iter x(1)*x(2)*x(3)*x(4) 
++ 
*iter x(2)*x(3)*x(4) 
++ 
*iter x(2)*x(4) 
++ 
*iter 1 
-- 
*iter x(2)*x(4) 
-- 
*iter x(2)*x(3)*x(4) 
++ 
*iter x(2)*x(4) 
 Testing additional properties...
poly x(0)*x(1)*x(2)*x(3)*x(4) + x(1)*x(2)*x(3)*x(4) + x(2)*x(3)*x(4) + x(2)*x(4) 
term length: 5
first index: 0
Finished.
----------------------
Executing testsuite/testring
----------------------
Exception caught sucessfully: No polynomial ring structure defined.
Variable 0:
: 1 nodes 0.5 minterms
1000 1

Variable 1:
: 1 nodes 0.5 minterms
0100 1

Variable 2:
: 1 nodes 0.5 minterms
0010 1

Variable 3:
: 1 nodes 0.5 minterms
0001 1

**** CUDD modifiable parameters ****
Hard limit for cache size: 1398101
Cache hit threshold for resizing: 30%
Garbage collection enabled: yes
Limit for fast unique table growth: 838860
Maximum number of variables sifted per reordering: 1000
Maximum number of variable swaps per reordering: 2000000
Maximum growth while sifting a variable: 1.2
Dynamic reordering of BDDs enabled: no
Default BDD reordering method: 4
Dynamic reordering of ZDDs enabled: no
Default ZDD reordering method: 4
Realignment of ZDDs to BDDs enabled: no
Realignment of BDDs to ZDDs enabled: no
Dead nodes counted in triggering reordering: no
Group checking criterion: 7
Recombination threshold: 0
Symmetry violation threshold: 0
Arc violation threshold: 0
GA population size: 0
Number of crossovers for GA: 0
Next reordering threshold: 4004
**** CUDD non-modifiable parameters ****
Memory in use: 4737732
Peak number of nodes: 1022
Peak number of live nodes: 4
Number of BDD variables: 0
Number of ZDD variables: 4
Number of cache entries: 262144
Number of cache look-ups: 0
Number of cache hits: 0
Number of cache insertions: 0
Number of cache collisions: 0
Number of cache deletions: 0
Cache used slots = 0.00% (expected 0.00%)
Soft limit for cache size: 5120
Number of buckets in unique table: 1280
Used buckets in unique table: 0.94% (expected 0.93%)
Number of BDD and ADD nodes: 4
Number of ZDD nodes: 8
Number of dead BDD and ADD nodes: 0
Number of dead ZDD nodes: 4
Total number of nodes allocated: 12
Total number of nodes reclaimed: 0
Garbage collections so far: 0
Time for garbage collection: 0.00 sec
Reorderings so far: 0
Time for reordering: 0.00 sec
is lexicographical?
1
is ordered?
1
is symmetric?
1
is degree ordering?
0
is total degree ordering?
0
has descending variables?
1
has ascending variables?
0
Testing DegLex ring... 
is lexicographical?
0
is ordered?
0
is symmetric?
1
is degree ordering?
1
is total degree ordering?
1
has descending variables?
1
has ascending variables?
0
poly x(2)*x(3)*x(4) + x(0)*x(1) + x(2) + x(4) + 1 
lead() x(2)*x(3)*x(4) 
leadExp() (2, 3, 4)
lmDeg() 3
lmDivisors() : 3 nodes 8 minterms
00--- 1

x(2)*x(3)*x(4) , x(0)*x(1) , x(2) , x(4) , 1 , 
2, 3, 1, 1, 0, 
max 3
min 0
ordered Iter
x(2)*x(3)*x(4) , x(0)*x(1) , x(2) , x(4) , 1 , ordered_ Iter
x(2)*x(3)*x(4) , x(0)*x(1) , x(2) , x(4) , 1 , lex-ordered Iter
x(0)*x(1) , x(2)*x(3)*x(4) , x(2) , x(4) , 1 , 
Testing dlex
order code?
1 (should be: 1)
is lexicographical?
0
is ordered?
0
is symmetric?
1
is degree ordering?
1
is total degree ordering?
1
has descending variables?
1
has ascending variables?
0
poly x(1)*x(3)*x(4) + x(2)*x(3)*x(4) + x(0)*x(1) + x(2) + x(4) + 1 
lead() x(1)*x(3)*x(4) 
boundedLead(deg()) x(1)*x(3)*x(4) 
leadExp() (1, 3, 4)
boundedLeadExp(deg()) (1, 3, 4)
deg() 3
lmDeg() 3
lmDivisors() : 3 nodes 8 minterms
0-0-- 1

ordered iteration... 
x(1)*x(3)*x(4) , x(2)*x(3)*x(4) , x(0)*x(1) , x(2) , x(4) , 1 , 
Comparision x(1)*x(4) < x(0)*x(2) 
 1
Comparision x(1)*x(2) < x(0)*x(4) 
 1
Comparision x(1) < x(0)*x(4) 
 1

Testing dp_asc
order code?
2 (should be: 2)
is lexicographical?
0
is ordered?
0
is symmetric?
1
is degree ordering?
1
is total degree ordering?
1
has descending variables?
0
has ascending variables?
1
poly x(2)*x(3)*x(4) + x(1)*x(3)*x(4) + x(0)*x(1) + x(4) + x(2) + 1 
lead() x(2)*x(3)*x(4) 
boundedLead(deg()) x(2)*x(3)*x(4) 
leadExp() (2, 3, 4)
boundedLeadExp(deg()) (2, 3, 4)
deg() 3
lmDeg() 3
lmDivisors() : 3 nodes 8 minterms
00--- 1

ordered iteration... 
x(2)*x(3)*x(4) , x(1)*x(3)*x(4) , x(0)*x(1) , x(4) , x(2) , 1 , 
Comparision x(1)*x(4) < x(0)*x(2) 
 0
Comparision x(1)*x(2) < x(0)*x(4) 
 0
Comparision x(1) < x(0)*x(4) 
 1

Testing changing from lex to dlex
is lexicographical?
1
is ordered?
1
is symmetric?
1
is degree ordering?
0
is total degree ordering?
0
has descending variables?
1
has ascending variables?
0
poly x(0)*x(1) + x(1)*x(3)*x(4) + x(2)*x(3)*x(4) + x(2) + x(4) + 1 
lead() x(0)*x(1) 
boundedLead(deg()) x(0)*x(1) 
leadExp() (0, 1)
boundedLeadExp(deg()) (0, 1)
deg() 3
lmDeg() 2
lmDivisors() : 2 nodes 4 minterms
--000 1
ordered iteration... 
x(0)*x(1) , x(1)*x(3)*x(4) , x(2)*x(3)*x(4) , x(2) , x(4) , 1 , 

CHANGE ordering!
boundedLead(deg()) x(1)*x(3)*x(4) 
leadExp() (1, 3, 4)
boundedLeadExp(deg()) (1, 3, 4)
deg() 3
lmDeg() 3
lmDivisors() : 3 nodes 8 minterms
0-0-- 1
ordered iteration... 
x(1)*x(3)*x(4) , x(2)*x(3)*x(4) , x(0)*x(1) , x(2) , x(4) , 1 , 
ordered exponent iteration... 
(1, 3, 4), (2, 3, 4), (0, 1), (2), (4), (), 

Testing changing from dp to lex
is lexicographical?
0
is ordered?
0
is symmetric?
1
is degree ordering?
1
is total degree ordering?
1
has descending variables?
0
has ascending variables?
1
poly x(2)*x(3)*x(4) + x(1)*x(3)*x(4) + x(0)*x(1) + x(4) + x(2) + 1 
lead() x(2)*x(3)*x(4) 
boundedLead(deg()) x(2)*x(3)*x(4) 
leadExp() (2, 3, 4)
boundedLeadExp(deg()) (2, 3, 4)
deg() 3
lmDeg() 3
lmDivisors() : 3 nodes 8 minterms
00--- 1
ordered iteration... 
x(2)*x(3)*x(4) , x(1)*x(3)*x(4) , x(0)*x(1) , x(4) , x(2) , 1 , 

CHANGE ordering!
boundedLead(deg()) x(0)*x(1) 
leadExp() (0, 1)
boundedLeadExp(deg()) (0, 1)
deg() 3
lmDeg() 2
lmDivisors() : 2 nodes 4 minterms
--000 1
ordered iteration... 
x(0)*x(1) , x(1)*x(3)*x(4) , x(2)*x(3)*x(4) , x(2) , x(4) , 1 , 
ordered exponent iteration... 
(0, 1), (1, 3, 4), (2, 3, 4), (2), (4), (), 

Testing hard-coded iteration for x(0)*x(1) + x(2)*x(3)*x(4) + x(2) + x(4) + 1 
lex
x(0)*x(1) , x(2)*x(3)*x(4) , x(2) , x(4) , 1 , 
dlex
x(2)*x(3)*x(4) , x(0)*x(1) , x(2) , x(4) , 1 , 
dp_asc
x(2)*x(3)*x(4) , x(0)*x(1) , x(4) , x(2) , 1 , 

bug?
polyx(0)*x(1)*x(2)*x(3) + x(0)*x(1)*x(3) + x(0)*x(1) + x(0)*x(2) + x(0) 
usedVariablesx(0)*x(1)*x(2)*x(3) 
usedVariablesExp(0, 1, 2, 3)
usedVariables.Exp(0, 1, 2, 3)
Test Variablenames
x(0)? x(0)
X? X
Testing cache flushing...
Finished.
2
0
1
2
0x2
----------------------
Executing testsuite/spoly
----------------------
Testing boolean ring variables
Poly 1: 
x(0)*x(1) + x(0)*x(2) + x(1) + x(4) 
Poly 2: 
x(0)*x(4) + x(4) 
spoly: 
x(0)*x(2)*x(4) + x(4) 
Expected result: 
x(0)*x(2)*x(4) + x(4) 
Equality? 
1
Finished.
----------------------
Executing testsuite/boolevars
----------------------
Testing boolean ring variables
x(0) 
x(1) 
Sum: 
x(0) + x(1) 
Zero polynomial: 
0 
0 += x 
x(0) 
var(1) > var(2)
1
var(2) > var(1)
0
Finished.
----------------------
Executing testsuite/cuddinterface
----------------------
Testing cudd interface
: 3 nodes 4 minterms
1-- 1
: 3 nodes 4 minterms
-1- 1
: 3 nodes 2 minterms
11- 1
: 1 nodes 1 minterms
100 1
: 1 nodes 1 minterms
010 1
: 2 nodes 1 minterms
110 1
: 5 nodes 5 minterms
11- 1
101 1
0-1 1
----------------------
Executing testsuite/errorcodes
----------------------
Testing important error codes
Throwing 'alright'
  Caught error # 0
    which says: No error.
Throwing 'failed'
  Caught error # 1
    which says: Unspecified error.
Throwing 'no_ring'
  Caught error # 2
    which says: No polynomial ring structure defined.

Testing all error codes 
Throwing error # 0
  Caught error # 0
    which says: No error.
Throwing error # 1
  Caught error # 1
    which says: Unspecified error.
Throwing error # 2
  Caught error # 2
    which says: No polynomial ring structure defined.
Throwing error # 3
  Caught error # 3
    which says: Invalid operation called.
Throwing error # 4
  Caught error # 4
    which says: Variable index out of bounds.
Throwing error # 5
  Caught error # 5
    which says: I/O error.
Throwing error # 6
  Caught error # 6
    which says: Sorry! Functionality not implemented yet.
----------------------
Executing testsuite/booleset
----------------------
Testing Boolean polynomials

BooleSet divisorsOf test
: 2 nodes 4 minterms
--000 1

: 2 nodes 4 minterms
--000 1

1
next
1
: 0 nodes 1 minterms
00000 1

: 0 nodes 1 minterms
00000 1

0
next
1
: 2 nodes 4 minterms
-000- 1

: 2 nodes 4 minterms
-000- 1

testing minimal elements
testing next minimal elements
bset : 6 nodes 4 minterms
11100 1
0101- 1
01000 1

: 1 nodes 1 minterms
01000 1

bset : 7 nodes 2 minterms
11111 1
01010 1



: 2 nodes 1 minterms
01010 1

Test exponents of x(0)*x(1) + x(1)*x(2)*x(3) + x(1)*x(2)*x(4) + x(2)*x(4) 
(0, 1), (1, 2, 3), (1, 2, 4), (2, 4), 
divide x(1)*x(3)  == 
(1, 3) ? 
(1, 3) ? 
multiply x(1)*x(2)*x(3)  == 
(1, 2, 3) ? 
(1, 2, 3) ? 
multiply x(1)*x(2)*x(3)*x(4)  == 
(1, 2, 3, 4) ? 
(1, 2, 3, 4) ? 
multiples x(2)*x(3)  wrt. x(0)*x(4) 
: 4 nodes 4 minterms
-011- 1

: 4 nodes 4 minterms
-011- 1

divisors x(2)*x(3) 
: 2 nodes 4 minterms
00--0 1

multiplesOf : 5 nodes 3 minterms
11000 1
01100 1
00001 1
|x(0)*x(3)*x(4) 
: 4 nodes 2 minterms
11000 1
01100 1

multiplesOf : 5 nodes 3 minterms
11000 1
01100 1
00001 1
|x(1) 
: 4 nodes 2 minterms
11000 1
01100 1

multiplesOf : 7 nodes 4 minterms
11-00 1
01110 1
00001 1
|x(1)*x(2) 
: 6 nodes 2 minterms
11100 1
01110 1

multiplesOf : 7 nodes 4 minterms
11-00 1
01110 1
00001 1
|0 
: is the empty ZDD

multiplesOf : 7 nodes 4 minterms
11-00 1
01110 1
00001 1
|1 

----------------------
Executing testsuite/strategy_initialization
----------------------
----------------------
Executing testsuite/boolepoly
----------------------
Testing Boolean polynomials
x(0) 
x(1) 
x(2) 
x(3) 
x(4) 
x*y : 
x(0)*x(1) 
x*y + z: 
x(0)*x(1) + x(2) 
(x + y)* z: 
x(0)*x(2) + x(1)*x(2) 
(x*v + y*v + z ) 
x(0)*x(3) + x(1)*x(3) + x(2) 
(x*v + y*v + z )* (v*y): 
x(0)*x(1)*x(3) + x(1)*x(2)*x(3) + x(1)*x(3) 
Node count: 5
N: 5

(x*v + y*v + z )* (v*y): 
x(0)*x(1)*x(3) + x(1)*x(2)*x(3) + x(1)*x(3) 
Equality? 
1

Nonequality? 
0

Division ok? 
1

Zero polynomial: isZero? 1
Zero polynomial: isOne? 0
Zero polynomial == 0? 1
Zero polynomial == 1? 0
Constant 0 == Zero polynomial? 1
Constant 1 == Zero polynomial? 0
One polynomial: isZero? 0
One polynomial: isOne? 1
One polynomial == 0? 0
One polynomial == 1? 1
Constant 0 == One polynomial? 0
Constant 1 == One polynomial? 1
Divisors of the leading monomial of  (x*z + y): 
: 2 nodes 4 minterms
-0-00 1

(x*z + y).reducibleBy(z): 1
(x*z*y + y).reducibleBy(y*z): 1
(x*z*y + y).reducibleBy(w): 0
(x*y + y).reducibleBy(z+w): 0
Multiplication tests: 
1
1
1
Degree: x + y*z 
2? 2
All degrees: x + y*z 
1
2
Degree: x + y*z + 1 
2? 2
All degrees: x + y*z + 1
1
2
0
x(0) 
x(1)*x(2) 
1 
1 
x(0) + x(1)*x(2) + 1  hasConstantTerm() ?
1
x(0) + x(1)*x(2)  hasConstantTerm() ?
0
x(1)*x(2) + 1  hasConstantTerm() ?
1
x(1)*x(2)  hasConstantTerm() ?
0
1  hasConstantTerm() ?
1
0  hasConstantTerm() ?
0
x(0)*x(1) + x(1)*x(2)  * x(2)*x(4) + x(3)*x(4) 
x(0)*x(1)*x(2)*x(4) + x(0)*x(1)*x(3)*x(4) + x(1)*x(2)*x(3)*x(4) + x(1)*x(2)*x(4) 

Going on...
1
1
1
x(0)*x(1)*x(2) + x(1)*x(2) + x(1)*x(3) + x(1)*x(4) 
x(0)*x(1) + x(1)*x(2) + x(1)*x(4) + x(3)*x(4) 
result x(0)*x(1)*x(2) + x(0)*x(1) + x(1)*x(3) + x(3)*x(4) 
test newnode.
newnode 0 x(1)*x(2) + x(2) + x(4)  x(3) + x(4) 
result x(0)*x(1)*x(2) + x(0)*x(2) + x(0)*x(4) + x(3) + x(4) 

Finished.

Finished.
----------------------
Executing testsuite/stringlit
----------------------

 
""
" "
"+"
" + "
"*"
","
", "
"x"
"("
")"
----------------------
Executing testsuite/leadterm
----------------------
Testing leading terms
x*y + z: 
x(0)*x(1) + x(2) 
leading term: 
x(0)*x(1) 
x*y*w + z*w: 
x(0)*x(1)*x(4) + x(2)*x(4) 
leading term: 
x(0)*x(1)*x(4) 
# ring variabled: 
5
lmdeg()
3
usedVariables()
x(0)*x(1)*x(2)*x(4) 
x(0)*x(1)*x(4) + x(1) + x(3)*x(4) + x(4) 
usedVariables()
x(0)*x(1)*x(3)*x(4) 
# usedVariables()
4

Leading term of simple monomial 
x(3) 
Leading term of empty diagram 
0 
Leading term of constant polynomial one
1 
Checkung handling of constants: x*y + z + 1
x(0)*x(1) + x(2) + 1 
Checkung handling of constants: x*y + z + 0
x(0)*x(1) + x(2) 
Test Modulus
x(2) 
x(2) 
x(0)*x(1) + x(2) 
x(0) + x(1) + x(2) 
Finished.
----------------------
Executing testsuite/monomial
----------------------
Testing Boolean monomials
x(0) 
x(1) 
x(2) 
x(3) 
x(4) 

Monomial x*y: x(0)*x(1) 

Monomial x*y*z: x(0)*x(1)*x(2)  degree: 3
(Sum of) Divisors: 
: 3 nodes 8 minterms
---00 1


Indices:
0
1
2
x*y*z*w / y*z: x(0)*x(4) 
x / x: 1 
x / y*z: 0 
x * y (as BooleVariable): x(0)*x(1) 
x*y*z / y (as BooleVariable): x(0)*x(2) 
x(0)*x(1)*x(4) .compare( x(0)*x(1)*x(4) ) :0
x(0)*x(1)*x(4) .compare( x(0)*x(1)*x(2) ) :-1
x(0)*x(1)*x(2) .compare( x(0)*x(1)*x(4) ) :1
x(0)*x(1)*x(4)  < x(0)*x(1)*x(2)  :1
x(0)*x(1)*x(4)  > x(0)*x(1)*x(2)  :0
x(0)*x(1)*x(4)  <= x(0)*x(1)*x(2)  :1
x(0)*x(1)*x(4)  >= x(0)*x(1)*x(2)  :0
x(0)*x(1)*x(4)  == x(0)*x(1)*x(2)  :0
x(0)*x(1)*x(4)  < x(0)*x(1)*x(4)  :0
x(0)*x(1)*x(4)  > x(0)*x(1)*x(4)  :0
x(0)*x(1)*x(4)  <= x(0)*x(1)*x(4)  :1
x(0)*x(1)*x(4)  >= x(0)*x(1)*x(4)  :1
x(0)*x(1)*x(4)  == x(0)*x(1)*x(4)  :1

x(0)*x(1)*x(3)*x(4) 
x(0)*x(1)*x(3)*x(4) .LCMDeg( x(0)*x(1)*x(2) ) :5
x(0)*x(1)*x(2) .LCMDeg( x(0)*x(1)*x(3)*x(4) ) :5
GCD( x(0)*x(1)*x(3)*x(4) , x(0)*x(1)*x(2) ) :x(0)*x(1) 
GCD( x(1)*x(3)*x(4) , x(0)*x(1)*x(2) ) :x(1) 
GCD( x(1)*x(3)*x(4) , x(0)*x(1)*x(2)*x(4) ) :x(1)*x(4) 

Multiples of x(0)*x(1) wrt. x(1)*x(2)*x(4) : 
: 4 nodes 4 minterms
11-0- 1
monom1
x(0)*x(1) 
print
0
1

Testing lowlevel divisors
: 2 nodes 4 minterms
-0-00 1

Testing lowlevel multiples
: 4 nodes 4 minterms
1-10- 1

x(0)*x(4)  < x(0) 
0
x(0)*x(4)  > x(0) 
1
x(0)*x(4)  < x(0) 
0
x(0)*x(4)  > x(0) 
1
Finished.
-------------------
Testsuite finished.
