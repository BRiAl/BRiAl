/*
 * This was automatically generated by modgen
 * version 0.2
 * module pb
 * Don't edit this file
 */


#line 0 "pb.cc"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <dlfcn.h>
#include <unistd.h>
#include <sys/stat.h>
#include <mod2.h>
#include <tok.h>
#include <structs.h>
#include <ipid.h>

#include <locals.h>
#include <omalloc.h>
#include "pb.h"
#line 9 "pb.cc"

typedef int idtyp;
idhdl enter_id(char *name, char *value, idtyp t)
{
  idhdl h;

  h=enterid(omStrDup(name),0, t, &(currPack->idroot), TRUE/*FALSE*/);
  if(h!=NULL) {
     switch(t) {
         case STRING_CMD: 
              omFree(IDSTRING(h));
              IDSTRING(h) = omStrDup(value);
              break;
         case PACKAGE_CMD: break;
         case PROC_CMD: break;
     }
  } else 
      Warn("Cannot create '%s'\n", name);
  return(h);
}

#line 27 "pb.cc"

idhdl add_singular_proc(FILE* binfp, char *procname,int line,
                       long pos, long end, BOOLEAN pstatic)
{
  idhdl h;
  procinfov pi;
  char *tempstr;
  h = enter_id(procname, NULL, PROC_CMD);
  if(h == NULL) return NULL;

  pi = IDPROC(h);

  pi->libname = omStrDup(currPack->libname);
  pi->procname = omStrDup(procname);
  pi->language = LANG_SINGULAR;
  pi->ref = 1;
  pi->is_static = pstatic;
  pi->data.s.proc_start = pos;
  pi->data.s.def_end    = pos;
  pi->data.s.help_start = 0L;
  pi->data.s.help_end   = 0L;
  pi->data.s.body_start = pos;
  pi->data.s.body_end   = end;
  pi->data.s.proc_end   = end;
  pi->data.s.example_start = 0L;
  pi->data.s.proc_lineno = line;
  pi->data.s.body_lineno = line;
  pi->data.s.example_lineno = 0;
  pi->data.s.help_chksum = 0;
  
  rewind(binfp);
  fseek(binfp,pos,SEEK_CUR);
  tempstr=(char *)omAlloc(end-pos+2);
  memset(tempstr,0,end-pos+2);
  fread(tempstr,sizeof(char),end-pos+1,binfp);
  pi->data.s.body = omStrDup(tempstr);
  omFree(tempstr);

  return(h);
}

unsigned long crccheck(
  char *file
  ) 
{
  unsigned char buf[BUFLEN1];
  unsigned long crc = 0;
  long length = 0;
  long bytes_read;
  register FILE *fp;

  // open the file
  fp = fopen (file, "rb");
  if (fp == NULL) return 0;

  // read the file chunk by chunk, determine the lenght and
  // start computing the checksum
  while ((bytes_read = fread (buf, 1, BUFLEN1, fp)) > 0)
  {
    unsigned char *cp = buf;
    length += bytes_read;
    while (bytes_read--)
      crc = (crc << 8) ^ crctab[((crc >> 24) ^ *(cp++)) & 0xFF];
    }

  // check if something went wrong and close the file
  if (ferror (fp)) return 0; 
  if (fclose(fp)==EOF) return 0;

  // second part of checksum computation
  bytes_read = length;
  while (bytes_read > 0) {
    crc = (crc << 8) ^ crctab[((crc >> 24) ^ bytes_read) & 0xFF];
    bytes_read >>= 8;
  }

  crc = ~crc & 0xFFFFFFFF;

  return(crc);
}

void fill_help_package();
void fill_example_package();

#line 2 "pb.mod"
/*
 *  $Id$
 *
 *  Python module
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
//#include <Python.h>
#include "pbwrapper.h"
#include <ideals.h>
ideal lex_bgb(ideal s);
#line 17 "pb.mod"


#line 127 "pb.cc"
extern "C" {
int mod_init(
  SModulFunctions* psModulFunctions
  )
{
  idhdl h;
  char * tempstr;
  char * tailstr;
  FILE * binfp; 
  int ret;
  struct stat sb; 

  tempstr = (char *)omAlloc(strlen(currPack->libname)+5);
  memset(tempstr,0,strlen(currPack->libname)+5);
  tailstr = strrchr(currPack->libname,'.');
  memcpy(tempstr,currPack->libname,strlen(currPack->libname)-strlen(tailstr));
  memcpy(tempstr+strlen(tempstr),".bin",4);
  ret=stat(tempstr,&sb);
  if(ret==0) { 
    if ((sb.st_mode & S_IFMT) == S_IFREG) { 
      if (crccheck(tempstr)!=crcsum)
      {   Warn("file %s does not agree with module version - ignoring file",tempstr);
          ret=-1;
      }
      if ((binfp = fopen(tempstr,"r")) == NULL) return -1;
    } 
    else 
      ret=-1; 
  }

  fill_help_package();
  fill_example_package();

#line 20 "pb.mod"
  enter_id("category","tests", STRING_CMD);
#line 22 "pb.mod"
  enter_id("version","$Id$", STRING_CMD);
#line 23 "pb.mod"
  enter_id("info","LIBRARY: kernel.lib  PROCEDURES OF GENERAL TYPE WRITEN IN C python(input); eval a string  in python", STRING_CMD);
#line 26 "pb.mod"
#line 27 "pb.mod"
  //Py_Initialize();
  //initSingular();
  //init_Singular();


#line 38 "pb.mod"
  psModulFunctions->iiAddCproc(currPack->libname,"lex_boolean_gb",FALSE, mod_lex_boolean_gb);

  if(ret!=-1) fclose(binfp);
  return 0;
}
}

#line 180 "pb.cc"
/* Help section */
void fill_help_package() {

#line 185 "pb.cc"
}  /* End of Help section */

/* Example section */
void fill_example_package() {

#line 193 "pb.cc"
} /* End of Example section */

#line 38 "pb.mod"
BOOLEAN mod_lex_boolean_gb(leftv __res, leftv __h)
{
#line 39 "pb.mod"
#line 201 "pb.cc"
 
#line 40 "pb.mod"
#line 204 "pb.cc"
  leftv __v = __h, __v_save;
  int __tok = NONE, __index = 0;
  sleftv __sa; leftv __za = &__sa;
  ideal a;
#line 40 "pb.mod"


#line 41 "pb.mod"
#line 213 "pb.cc"
  if(__v==NULL) goto mod_lex_boolean_gb_error;
  __tok = __v->Typ();
  if((__index=iiTestConvert(__tok, IDEAL_CMD))==0)
     goto mod_lex_boolean_gb_error;
  __v_save = __v->next;
  __v->next = NULL;
  if(iiConvert(__tok, IDEAL_CMD, __index, __v, __za))
     goto mod_lex_boolean_gb_error;
  __v = __v_save;
  a = (ideal)__za->Data();
  if(__v!=NULL) { __tok = __v->Typ(); goto mod_lex_boolean_gb_error; }

  goto mod_lex_boolean_gb_ok;
  mod_lex_boolean_gb_error:
    Werror("lex_boolean_gb(`%s`) is not supported", Tok2Cmdname(__tok));
    Werror("expected lex_boolean_gb('ideal')");
    return TRUE;
  mod_lex_boolean_gb_ok:
#line 41 "pb.mod"

  ideal h;
  h=lex_bgb(a);
  __res->data =(void*) h;
#line 237 "pb.cc"
  __res->rtyp = IDEAL_CMD;
  return FALSE;

}


#line 243 "pb.cc"
#line 53 "pb.mod"
ideal lex_bgb(ideal s){
return do_lex_gb(s);
 
}
