<html>
<head><title>The cudd package: all functions </title></head>
<body>


<HR>
<DL>
<dt><pre>
<A NAME="AssessPathLength"></A>
static unsigned int <I></I>
<B>AssessPathLength</B>(
  unsigned int * <b>pathLengthArray</b>, <i>array determining number of nodes belonging to the different path lengths</i>
  int  <b>threshold</b>, <i>threshold to determine maximum allowable nodes in the subset</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  unsigned int * <b>excess</b>, <i>number of nodes labeled maxpath required in the subset</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> Chooses the maximum allowable path length under each node.
  The corner cases are when the threshold is larger than the number
  of nodes in the BDD iself, in which case 'numVars + 1' is returned.
  If all nodes of a particular path length are needed, then the
  maxpath returned is the next one with excess nodes = 0;
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="BAapplyBias"></A>
static int <I></I>
<B>BAapplyBias</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>b</b>, <i></i>
  ApproxInfo * <b>info</b>, <i></i>
  DdHashTable * <b>cache</b> <i></i>
)
</pre>
<dd> Finds don't care nodes by traversing f and b in parallel.
  Returns the care status of the visited f node if successful; CARE_ERROR
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBiasedUnderApprox">cuddBiasedUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="BAmarkNodes"></A>
static int <I></I>
<B>BAmarkNodes</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be analyzed</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>threshold</b>, <i>when to stop approximating</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Marks nodes for remapping. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBiasedUnderApprox">cuddBiasedUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="BuildConjuncts"></A>
static Conjuncts * <I></I>
<B>BuildConjuncts</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  st_table * <b>distanceTable</b>, <i></i>
  st_table * <b>cacheTable</b>, <i></i>
  int  <b>approxDistance</b>, <i></i>
  int  <b>maxLocalRef</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>mintermTable</b> <i></i>
)
</pre>
<dd> Builds the conjuncts recursively, bottom up. Constants
  are returned as (f, f). The cache is checked for previously computed
  result. The decomposition points are determined by the local
  reference count of this node and the longest distance from the
  constant. At the decomposition point, the factors returned are (f,
  1). Recur on the two children. The order is determined by the
  heavier branch. Combine the factors of the two children and pick the
  one that already occurs in the gh table. Occurence in g is indicated
  by value 1, occurence in h by 2, occurence in both 3.
<p>

<dd> <b>See Also</b> <code><a href="#cuddConjunctsAux">cuddConjunctsAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="BuildSubsetBdd"></A>
static DdNode * <I></I>
<B>BuildSubsetBdd</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  GlobalInfo_t * <b>gInfo</b>, <i>global information</i>
  st_table * <b>pathTable</b>, <i>path table with path lengths and computed results</i>
  DdNode * <b>node</b>, <i>current node</i>
  struct AssortedInfo * <b>info</b>, <i>assorted information structure</i>
  st_table * <b>subsetNodeTable</b> <i>table storing computed results</i>
)
</pre>
<dd> Builds the BDD with nodes labeled with path length
  under maxpath and as many nodes labeled maxpath as determined by the
  threshold. The procedure uses the path table to determine which nodes
  in the original bdd need to be retained. This procedure picks a
  shortest path (tie break decided by taking the child with the shortest
  distance to the constant) and recurs down the path till it reaches the
  constant. the procedure then starts building the subset upward from
  the constant. All nodes labeled by path lengths less than the given
  maxpath are used to build the subset.  However, in the case of nodes
  that have label equal to maxpath, as many are chosen as required by
  the threshold. This number is stored in the info structure in the
  field thresholdReached. This field is decremented whenever a node
  labeled maxpath is encountered and the nodes labeled maxpath are
  aggregated in a maxpath table. As soon as the thresholdReached count
  goes to 0, the shortest path from this node to the constant is found.
  The extraction of nodes with the above labeling is based on the fact
  that each node, labeled with a path length, P, has at least one child
  labeled P or less. So extracting all nodes labeled a given path length
  P ensures complete paths between the root and the constant. Extraction
  of a partial number of nodes with a given path length may result in
  incomplete paths and hence the additional number of nodes are grabbed
  to complete the path. Since the Bdd is built bottom-up, other nodes
  labeled maxpath do lie on complete paths.  The procedure may cause the
  subset to have a larger or smaller number of nodes than the specified
  threshold. The increase in the number of nodes is caused by the
  building of a subset and the reduction by recombination. However in
  most cases, the recombination overshadows the increase and the
  procedure returns a result with lower number of nodes than specified.
  The subsetNodeTable is NIL when there is no hard limit on the number
  of nodes. Further efforts towards keeping the subset closer to the
  threshold number were abandoned in favour of keeping the procedure
  simple and fast.
<p>

<dd> <b>Side Effects</b> SubsetNodeTable is changed if it is not NIL.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="BuildSubsetBdd"></A>
static DdNode * <I></I>
<B>BuildSubsetBdd</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int * <b>size</b>, <i>current size of the subset</i>
  st_table * <b>visitedTable</b>, <i>visited table storing all node data</i>
  int  <b>threshold</b>, <i></i>
  st_table * <b>storeTable</b>, <i></i>
  st_table * <b>approxTable</b> <i></i>
)
</pre>
<dd> The procedure carries out the building of the subset BDD
  starting at the root. Using the three different counts labelling each node,
  the procedure chooses the heavier branch starting from the root and keeps
  track of the number of nodes it discards at each step, thus keeping count
  of the size of the subset BDD dynamically. Once the threshold is satisfied,
  the procedure then calls ITE to build the BDD.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE *þvalueþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE *þvalueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE *þvalueþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE *þvalueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE þcþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE þepþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE þepþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE þupperþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE þupperþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE þvalueþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE þvalueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CUDD_VALUE_TYPE þvalueþ"></A>
 <I></I>
<B>CUDD_VALUE_TYPE þvalueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="CheckInTables"></A>
static Conjuncts * <I></I>
<B>CheckInTables</B>(
  DdNode * <b>node</b>, <i></i>
  DdNode * <b>g1</b>, <i></i>
  DdNode * <b>h1</b>, <i></i>
  DdNode * <b>g2</b>, <i></i>
  DdNode * <b>h2</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b>, <i></i>
  int * <b>outOfMem</b> <i></i>
)
</pre>
<dd> Check if the two pairs exist in the table. If any of
  the conjuncts do exist, store in the cache and return the
  corresponding pair.
<p>

<dd> <b>See Also</b> <code><a href="#ZeroCase">ZeroCase</a>
<a href="#BuildConjuncts">BuildConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CheckTablesCacheAndReturn"></A>
static Conjuncts * <I></I>
<B>CheckTablesCacheAndReturn</B>(
  DdNode * <b>node</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b> <i></i>
)
</pre>
<dd> Check the tables for the existence of pair and return
  one combination, cache the result. The assumption is that one of the
  conjuncts is already in the tables.
<p>

<dd> <b>Side Effects</b> g and h referenced for the cache
<p>

<dd> <b>See Also</b> <code><a href="#ZeroCase">ZeroCase</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="ConjunctsFree"></A>
static void <I></I>
<B>ConjunctsFree</B>(
  DdManager * <b>dd</b>, <i></i>
  Conjuncts * <b>factors</b> <i></i>
)
</pre>
<dd> Free factors structure
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CorrelCleanUp"></A>
static enum st_retval <I></I>
<B>CorrelCleanUp</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees memory associated with hash table. Returns
  ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="CorrelCompare"></A>
static int <I></I>
<B>CorrelCompare</B>(
  const char * <b>key1</b>, <i></i>
  const char * <b>key2</b> <i></i>
)
</pre>
<dd> Compares two hash table entries. Returns 0 if they are
  identical; 1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="CorrelHash"></A>
static int <I></I>
<B>CorrelHash</B>(
  char * <b>key</b>, <i></i>
  int  <b>modulus</b> <i></i>
)
</pre>
<dd> Hashes a hash table entry. It is patterned after
  st_strhash. Returns a value between 0 and modulus.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="CountMinterms"></A>
static double <I></I>
<B>CountMinterms</B>(
  DdNode * <b>node</b>, <i></i>
  double  <b>max</b>, <i></i>
  st_table * <b>mintermTable</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Count the number of minterms of each node ina a BDD and
  store it in a hash table.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CreateBotDist"></A>
static NodeStat * <I></I>
<B>CreateBotDist</B>(
  DdNode * <b>node</b>, <i></i>
  st_table * <b>distanceTable</b> <i></i>
)
</pre>
<dd> Get longest distance of node from constant. Returns the
  distance of the root from the constant if successful; CUDD_OUT_OF_MEM
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CreateBotDist"></A>
static int <I></I>
<B>CreateBotDist</B>(
  DdNode * <b>node</b>, <i>current node</i>
  st_table * <b>pathTable</b>, <i>path table with path lengths</i>
  unsigned int * <b>pathLengthArray</b>, <i>array that stores number of nodes belonging to a particular path length.</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> Labels each node with the shortest distance from the constant.
  This is done in a DFS search of the BDD. Each node has an odd
  and even parity distance from the sink (since there exists paths to both
  zero and one) which is less than MAXSHORTINT. At each node these distances
  are updated using the minimum distance of its children from the constant.
  SInce now both the length from the root and child is known, the minimum path
  length(length of the shortest path between the root and the constant that
  this node lies on) of this node can be calculated and used to update the
  pathLengthArray
<p>

<dd> <b>Side Effects</b> Updates Path Table and path length array
<p>

<dd> <b>See Also</b> <code><a href="#CreatePathTable">CreatePathTable</a>
<a href="#CreateTopDist">CreateTopDist</a>
<a href="#AssessPathLength">AssessPathLength</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="CreatePathTable"></A>
static st_table * <I></I>
<B>CreatePathTable</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  GlobalInfo_t * <b>gInfo</b>, <i>global information</i>
  DdNode * <b>node</b>, <i>root of function</i>
  unsigned int * <b>pathLengthArray</b>, <i>array of path lengths to store nodes labeled with the various path lengths</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> The outer procedure to label each node with its shortest
  distance from the root and constant. Calls CreateTopDist and CreateBotDist.
  The basis for computing the distance between root and constant is that
  the distance may be the sum of even distances from the node to the root
  and constant or the sum of odd distances from the node to the root and
  constant.  Both CreateTopDist and CreateBotDist create the odd and
  even parity distances from the root and constant respectively.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#CreateTopDist">CreateTopDist</a>
<a href="#CreateBotDist">CreateBotDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="CreateTopDist"></A>
static void <I></I>
<B>CreateTopDist</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  GlobalInfo_t * <b>gInfo</b>, <i>global information</i>
  st_table * <b>pathTable</b>, <i>hast table to store path lengths</i>
  int  <b>parentPage</b>, <i>the pointer to the page on which the first parent in the queue is to be found.</i>
  int  <b>parentQueueIndex</b>, <i>pointer to the first parent on the page</i>
  int  <b>topLen</b>, <i>current distance from the root</i>
  DdNode ** <b>childPage</b>, <i>pointer to the page on which the first child is to be added.</i>
  int  <b>childQueueIndex</b>, <i>pointer to the first child</i>
  int  <b>numParents</b>, <i>number of parents to process in this recursive call</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> Labels each node with its shortest distance from the root.
  This is done in a BFS search of the BDD. The nodes are processed
  in a queue implemented as pages(array) to reduce memory fragmentation.
  An entry is created for each node visited. The distance from the root
  to the node with the corresponding  parity is updated. The procedure
  is called recursively each recusion level handling nodes at a given
  level from the root.
<p>

<dd> <b>Side Effects</b> Creates entries in the pathTable
<p>

<dd> <b>See Also</b> <code><a href="#CreatePathTable">CreatePathTable</a>
<a href="#CreateBotDist">CreateBotDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AggregationType þgcþ"></A>
 <I></I>
<B>Cudd_AggregationType þgcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_HookType þwhereþ"></A>
 <I></I>
<B>Cudd_HookType þwhereþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_HookType þwhereþ"></A>
 <I></I>
<B>Cudd_HookType þwhereþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_HookType þwhereþ"></A>
 <I></I>
<B>Cudd_HookType þwhereþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_ReorderingType *þmethodþ"></A>
 <I></I>
<B>Cudd_ReorderingType *þmethodþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_ReorderingType *þmethodþ"></A>
 <I></I>
<B>Cudd_ReorderingType *þmethodþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_ReorderingType þmethodþ"></A>
 <I></I>
<B>Cudd_ReorderingType þmethodþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="Cudd_ReorderingType þmethodþ"></A>
 <I></I>
<B>Cudd_ReorderingType þmethodþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DD_PRFP þPifuncþfunction used to build Pi if it is NULL"></A>
 <I></I>
<B>DD_PRFP þPifuncþfunction used to build Pi if it is NULL</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaDigit þliteralþ"></A>
 <I></I>
<B>DdApaDigit þliteralþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þbþ"></A>
 <I></I>
<B>DdApaNumber þbþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þdestþ"></A>
 <I></I>
<B>DdApaNumber þdestþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þdiffþ"></A>
 <I></I>
<B>DdApaNumber þdiffþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þnumberþ"></A>
 <I></I>
<B>DdApaNumber þnumberþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þnumberþ"></A>
 <I></I>
<B>DdApaNumber þnumberþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þquotientþ"></A>
 <I></I>
<B>DdApaNumber þquotientþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þquotientþ"></A>
 <I></I>
<B>DdApaNumber þquotientþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þsecondþ"></A>
 <I></I>
<B>DdApaNumber þsecondþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdApaNumber þsumþ"></A>
 <I></I>
<B>DdApaNumber þsumþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdGen *þgenþ"></A>
 <I></I>
<B>DdGen *þgenþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdGen *þgenþ"></A>
 <I></I>
<B>DdGen *þgenþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þddþ"></A>
 <I></I>
<B>DdManager *þddþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þmanagerþ"></A>
 <I></I>
<B>DdManager *þmanagerþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þtableþ"></A>
 <I></I>
<B>DdManager *þtableþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þtableþ"></A>
 <I></I>
<B>DdManager *þtableþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þtableþ"></A>
 <I></I>
<B>DdManager *þtableþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þtableþ"></A>
 <I></I>
<B>DdManager *þtableþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdManager *þuniqueþ"></A>
 <I></I>
<B>DdManager *þuniqueþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þconjunctsþaddress of the array of conjuncts"></A>
 <I></I>
<B>DdNode ***þconjunctsþaddress of the array of conjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þconjunctsþaddress of the array of conjuncts"></A>
 <I></I>
<B>DdNode ***þconjunctsþaddress of the array of conjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þconjunctsþaddress of the array of conjuncts"></A>
 <I></I>
<B>DdNode ***þconjunctsþaddress of the array of conjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þconjunctsþaddress of the first factor"></A>
 <I></I>
<B>DdNode ***þconjunctsþaddress of the first factor</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þdisjunctsþaddress of the array of the disjuncts"></A>
 <I></I>
<B>DdNode ***þdisjunctsþaddress of the array of the disjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þdisjunctsþaddress of the array of the disjuncts"></A>
 <I></I>
<B>DdNode ***þdisjunctsþaddress of the array of the disjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þdisjunctsþaddress of the array of the disjuncts"></A>
 <I></I>
<B>DdNode ***þdisjunctsþaddress of the array of the disjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode ***þdisjunctsþaddress of the array of the disjuncts"></A>
 <I></I>
<B>DdNode ***þdisjunctsþaddress of the array of the disjuncts</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þgþ"></A>
 <I></I>
<B>DdNode **þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þnodeþ"></A>
 <I></I>
<B>DdNode **þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þnodeþ"></A>
 <I></I>
<B>DdNode **þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þonlyGþcube of variables only in g"></A>
 <I></I>
<B>DdNode **þonlyGþcube of variables only in g</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þvectorOffþ"></A>
 <I></I>
<B>DdNode **þvectorOffþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þvectorþ"></A>
 <I></I>
<B>DdNode **þvectorþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þvectorþ"></A>
 <I></I>
<B>DdNode **þvectorþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þvectorþ"></A>
 <I></I>
<B>DdNode **þvectorþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þyþarray of y variables"></A>
 <I></I>
<B>DdNode **þyþarray of y variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þyþarray of y variables"></A>
 <I></I>
<B>DdNode **þyþarray of y variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þyþarray of y variables"></A>
 <I></I>
<B>DdNode **þyþarray of y variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þyþarray of y variables"></A>
 <I></I>
<B>DdNode **þyþarray of y variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þyþarray of y variables"></A>
 <I></I>
<B>DdNode **þyþarray of y variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þzdd_Iþ"></A>
 <I></I>
<B>DdNode **þzdd_Iþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þzþarray of z variables"></A>
 <I></I>
<B>DdNode **þzþarray of z variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode **þzþarray of z variables"></A>
 <I></I>
<B>DdNode **þzþarray of z variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þBþ"></A>
 <I></I>
<B>DdNode *þBþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þBþ"></A>
 <I></I>
<B>DdNode *þBþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þDþ"></A>
 <I></I>
<B>DdNode *þDþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þDþ"></A>
 <I></I>
<B>DdNode *þDþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þPþ"></A>
 <I></I>
<B>DdNode *þPþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þPþ"></A>
 <I></I>
<B>DdNode *þPþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þQþ"></A>
 <I></I>
<B>DdNode *þQþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þQþ"></A>
 <I></I>
<B>DdNode *þQþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þQþ"></A>
 <I></I>
<B>DdNode *þQþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þQþ"></A>
 <I></I>
<B>DdNode *þQþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þUþ"></A>
 <I></I>
<B>DdNode *þUþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þYþ"></A>
 <I></I>
<B>DdNode *þYþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þbckþ"></A>
 <I></I>
<B>DdNode *þbckþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcubeþ"></A>
 <I></I>
<B>DdNode *þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþ"></A>
 <I></I>
<B>DdNode *þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþ"></A>
 <I></I>
<B>DdNode *þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþ"></A>
 <I></I>
<B>DdNode *þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþ"></A>
 <I></I>
<B>DdNode *þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþ"></A>
 <I></I>
<B>DdNode *þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþ"></A>
 <I></I>
<B>DdNode *þcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þcþconstraint (care set)"></A>
 <I></I>
<B>DdNode *þcþconstraint (care set)</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þepsilonþ"></A>
 <I></I>
<B>DdNode *þepsilonþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþ"></A>
 <I></I>
<B>DdNode *þfþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþDD whose support is sought"></A>
 <I></I>
<B>DdNode *þfþDD whose support is sought</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþDD whose support is sought"></A>
 <I></I>
<B>DdNode *þfþDD whose support is sought</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþDD whose support size is sought"></A>
 <I></I>
<B>DdNode *þfþDD whose support size is sought</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþZDD whose support is sought"></A>
 <I></I>
<B>DdNode *þfþZDD whose support is sought</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþfunction against which to expand"></A>
 <I></I>
<B>DdNode *þfþfunction against which to expand</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþfunction in which to remap variables"></A>
 <I></I>
<B>DdNode *þfþfunction in which to remap variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þfþfunction of which the cube is to be made a prime"></A>
 <I></I>
<B>DdNode *þfþfunction of which the cube is to be made a prime</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþ"></A>
 <I></I>
<B>DdNode *þgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þgþsecond operand"></A>
 <I></I>
<B>DdNode *þgþsecond operand</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þhþ"></A>
 <I></I>
<B>DdNode *þhþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þhþ"></A>
 <I></I>
<B>DdNode *þhþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þhþ"></A>
 <I></I>
<B>DdNode *þhþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þhþ"></A>
 <I></I>
<B>DdNode *þhþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þhþ"></A>
 <I></I>
<B>DdNode *þhþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnodeþ"></A>
 <I></I>
<B>DdNode *þnodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnþ"></A>
 <I></I>
<B>DdNode *þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnþ"></A>
 <I></I>
<B>DdNode *þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnþ"></A>
 <I></I>
<B>DdNode *þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnþ"></A>
 <I></I>
<B>DdNode *þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þnþ"></A>
 <I></I>
<B>DdNode *þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þp_nodeþ"></A>
 <I></I>
<B>DdNode *þp_nodeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þphaseBddþcube of the phases"></A>
 <I></I>
<B>DdNode *þphaseBddþcube of the phases</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þuþ"></A>
 <I></I>
<B>DdNode *þuþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þuþupper bound"></A>
 <I></I>
<B>DdNode *þuþupper bound</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdNode *þvarþvariable"></A>
 <I></I>
<B>DdNode *þvarþvariable</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="DdTlcInfo *þtþ"></A>
 <I></I>
<B>DdTlcInfo *þtþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="EpDouble *þepdþ"></A>
 <I></I>
<B>EpDouble *þepdþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþ"></A>
 <I></I>
<B>FILE *þfpþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþ"></A>
 <I></I>
<B>FILE *þfpþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþ"></A>
 <I></I>
<B>FILE *þfpþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþ"></A>
 <I></I>
<B>FILE *þfpþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþ"></A>
 <I></I>
<B>FILE *þfpþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþpointer to the dump file"></A>
 <I></I>
<B>FILE *þfpþpointer to the dump file</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþpointer to the dump file"></A>
 <I></I>
<B>FILE *þfpþpointer to the dump file</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþpointer to the dump file"></A>
 <I></I>
<B>FILE *þfpþpointer to the dump file</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþpointer to the dump file"></A>
 <I></I>
<B>FILE *þfpþpointer to the dump file</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="FILE *þfpþpointer to the dump file"></A>
 <I></I>
<B>FILE *þfpþpointer to the dump file</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="MarkCacheCleanUp"></A>
static enum st_retval <I></I>
<B>MarkCacheCleanUp</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees memory associated with computed table of
  cuddBddLICMarkEdges. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="MarkCacheCompare"></A>
static int <I></I>
<B>MarkCacheCompare</B>(
  const char * <b>ptr1</b>, <i></i>
  const char * <b>ptr2</b> <i></i>
)
</pre>
<dd> Comparison function for the computed table of
  cuddBddLICMarkEdges. Returns 0 if the two nodes of the key are equal; 1
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="MarkCacheHash"></A>
static int <I></I>
<B>MarkCacheHash</B>(
  char * <b>ptr</b>, <i></i>
  int  <b>modulus</b> <i></i>
)
</pre>
<dd> Hash function for the computed table of
  cuddBddLICMarkEdges.  Returns the bucket number.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="MtrNode *þtreeþ"></A>
 <I></I>
<B>MtrNode *þtreeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="MtrNode *þtreeþ"></A>
 <I></I>
<B>MtrNode *þtreeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="PMX"></A>
static int <I></I>
<B>PMX</B>(
  int  <b>maxvar</b> <i></i>
)
</pre>
<dd> Performs the crossover between two randomly chosen
  parents, and creates two children, x1 and x2. Uses the Partially
  Matched Crossover operator.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="PairInTables"></A>
static int <I></I>
<B>PairInTables</B>(
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  st_table * <b>ghTable</b> <i></i>
)
</pre>
<dd> .Check whether the given pair is in the tables.  gTable
  and hTable are combined.
  absence in both is indicated by 0,
  presence in gTable is indicated by 1,
  presence in hTable by 2 and
  presence in both by 3.
  The values returned by this function are PAIR_ST,
  PAIR_CR, G_ST, G_CR, H_ST, H_CR, BOTH_G, BOTH_H, NONE.
  PAIR_ST implies g in gTable and h in hTable
  PAIR_CR implies g in hTable and h in gTable
  G_ST implies g in gTable and h not in any table
  G_CR implies g in hTable and h not in any table
  H_ST implies h in hTable and g not in any table
  H_CR implies h in gTable and g not in any table
  BOTH_G implies both in gTable
  BOTH_H implies both in hTable
  NONE implies none in table;
<p>

<dd> <b>See Also</b> <code><a href="#CheckTablesCacheAndReturn">CheckTablesCacheAndReturn</a>
<a href="#CheckInTables">CheckInTables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="PickOnePair"></A>
static Conjuncts * <I></I>
<B>PickOnePair</B>(
  DdNode * <b>node</b>, <i></i>
  DdNode * <b>g1</b>, <i></i>
  DdNode * <b>h1</b>, <i></i>
  DdNode * <b>g2</b>, <i></i>
  DdNode * <b>h2</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b> <i></i>
)
</pre>
<dd> Check the tables for the existence of pair and return
  one combination, store in cache. The pair that has more pointers to
  it is picked. An approximation of the number of local pointers is
  made by taking the reference count of the pairs sent.
<p>

<dd> <b>See Also</b> <code><a href="#ZeroCase">ZeroCase</a>
<a href="#BuildConjuncts">BuildConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="RAbuildSubset"></A>
static DdNode * <I></I>
<B>RAbuildSubset</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  ApproxInfo * <b>info</b> <i>node info</i>
)
</pre>
<dd> Builds the subset BDDfor cuddRemapUnderApprox.  Based
  on the info table, performs remapping or replacement at selected
  nodes. Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRemapUnderApprox">cuddRemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="RAmarkNodes"></A>
static int <I></I>
<B>RAmarkNodes</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be analyzed</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>threshold</b>, <i>when to stop approximating</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Marks nodes for remapping. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRemapUnderApprox">cuddRemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="ResizeCountMintermPages"></A>
static void <I></I>
<B>ResizeCountMintermPages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the minterm
  counts.  The procedure  moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of minterm pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="ResizeCountNodePages"></A>
static void <I></I>
<B>ResizeCountNodePages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the node counts.
  The procedure  moves the counter to the next page when the end of
  the page is reached and allocates new pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="ResizeNodeDataPages"></A>
static void <I></I>
<B>ResizeNodeDataPages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the node data
  The procedure  moves the counter to the next page when the end of
  the page is reached and allocates new pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="ResizeNodeDistPages"></A>
static void <I></I>
<B>ResizeNodeDistPages</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  GlobalInfo_t * <b>gInfo</b> <i>global information</i>
)
</pre>
<dd> Resize the number of pages allocated to store the distances
  related to each node. The procedure  moves the counter to the
  next page when the end of the page is reached and allocates new
  pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of  pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="ResizeQueuePages"></A>
static void <I></I>
<B>ResizeQueuePages</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  GlobalInfo_t * <b>gInfo</b> <i>global information</i>
)
</pre>
<dd> Resize the number of pages allocated to store nodes in the BFS
  traversal of the Bdd. The procedure  moves the counter to the
  next page when the end of the page is reached and allocates new
  pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="StoreNodes"></A>
static void <I></I>
<B>StoreNodes</B>(
  st_table * <b>storeTable</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> rocedure to recursively store nodes that are retained in the subset.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#StoreNodes">StoreNodes</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountMintermAux"></A>
static double <I></I>
<B>SubsetCountMintermAux</B>(
  DdNode * <b>node</b>, <i>function to analyze</i>
  double  <b>max</b>, <i>number of minterms of constant 1</i>
  st_table * <b>table</b> <i>visitedTable table</i>
)
</pre>
<dd> Recursively counts minterms of each node in the DAG.
  Similar to the cuddCountMintermAux which recursively counts the
  number of minterms for the dag rooted at each node in terms of the
  total number of variables (max). This procedure creates the node
  data structure and stores the minterm count as part of the node
  data structure.
<p>

<dd> <b>Side Effects</b> Creates structures of type node quality and fills the st_table
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountMinterm">SubsetCountMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountMinterm"></A>
static st_table * <I></I>
<B>SubsetCountMinterm</B>(
  DdNode * <b>node</b>, <i>function to be analyzed</i>
  int  <b>nvars</b> <i>number of variables node depends on</i>
)
</pre>
<dd> Counts minterms of each node in the DAG. Similar to the
  Cudd_CountMinterm procedure except this returns the minterm count for
  all the nodes in the bdd in an st_table.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountMintermAux">SubsetCountMintermAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountNodesAux"></A>
static int <I></I>
<B>SubsetCountNodesAux</B>(
  DdNode * <b>node</b>, <i>current node</i>
  st_table * <b>table</b>, <i>table to update node count, also serves as visited table.</i>
  double  <b>max</b> <i>maximum number of variables</i>
)
</pre>
<dd> Recursively counts the number of nodes under the dag.
  Also counts the number of nodes under the lighter child of
  this node. . Note that the same dag may be the lighter child of two
  different nodes and have different counts. As with the minterm counts,
  the node counts are stored in pages to be space efficient and the
  address for these node counts are stored in an st_table associated
  to each node.
<p>

<dd> <b>Side Effects</b> Updates the node data table with node counts
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountNodes">SubsetCountNodes</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountNodes"></A>
static int <I></I>
<B>SubsetCountNodes</B>(
  DdNode * <b>node</b>, <i>function to be analyzed</i>
  st_table * <b>table</b>, <i>node quality table</i>
  int  <b>nvars</b> <i>number of variables node depends on</i>
)
</pre>
<dd> Counts the nodes under the current node and its lighter
  child. Calls a recursive procedure to count the number of nodes of
  a DAG rooted at a particular node and the number of nodes taken by its
  lighter child.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountNodesAux">SubsetCountNodesAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="UAbuildSubset"></A>
static DdNode * <I></I>
<B>UAbuildSubset</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  ApproxInfo * <b>info</b> <i>node info</i>
)
</pre>
<dd> Builds the subset BDD. Based on the info table,
  replaces selected nodes by zero. Returns a pointer to the result if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="UAmarkNodes"></A>
static int <I></I>
<B>UAmarkNodes</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be analyzed</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>threshold</b>, <i>when to stop approximating</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Marks nodes for replacement by zero. Returns 1 if successful;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="ZeroCase"></A>
static Conjuncts * <I></I>
<B>ZeroCase</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  Conjuncts * <b>factorsNv</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b>, <i></i>
  int  <b>switched</b> <i></i>
)
</pre>
<dd> If one child is zero, do explicitly what Restrict does or better.
  First separate a variable and its child in the base case. In case of a cube
  times a function, separate the cube and function. As a last resort, look in
  tables.
<p>

<dd> <b>Side Effects</b> Frees the BDDs in factorsNv. factorsNv itself is not freed
  because it is freed above.
<p>

<dd> <b>See Also</b> <code><a href="#BuildConjuncts">BuildConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="addBddDoInterval"></A>
static DdNode * <I></I>
<B>addBddDoInterval</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddInterval.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#addBddDoThreshold">addBddDoThreshold</a>
<a href="#addBddDoStrictThreshold">addBddDoStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addBddDoIthBit"></A>
static DdNode * <I></I>
<B>addBddDoIthBit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>index</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddIthBit.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addBddDoStrictThreshold"></A>
static DdNode * <I></I>
<B>addBddDoStrictThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>val</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddStrictThreshold.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#addBddDoThreshold">addBddDoThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addBddDoThreshold"></A>
static DdNode * <I></I>
<B>addBddDoThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>val</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddThreshold.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#addBddDoStrictThreshold">addBddDoStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addCheckPositiveCube"></A>
static int <I></I>
<B>addCheckPositiveCube</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Checks whether cube is an ADD representing the product of
  positive literals. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="addDoIthBit"></A>
static DdNode * <I></I>
<B>addDoIthBit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>index</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addIthBit.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddFind.c"TARGET="ABSTRACT"><CODE>cuddAddFind.c</CODE></A>

<dt><pre>
<A NAME="addMMRecur"></A>
static DdNode * <I></I>
<B>addMMRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>A</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  int  <b>topP</b>, <i></i>
  int * <b>vars</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addMatrixMultiply.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="addMultiplicityGroups"></A>
static int <I></I>
<B>addMultiplicityGroups</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  MtrNode * <b>treenode</b>, <i>current tree node</i>
  int  <b>multiplicity</b>, <i>how many ZDD vars per BDD var</i>
  char * <b>vmask</b>, <i>variable pairs for which a group has been already built</i>
  char * <b>lmask</b> <i>levels for which a group has already been built</i>
)
</pre>
<dd> Adds multiplicity groups to a ZDD variable group tree.
  Returns 1 if successful; 0 otherwise. This function creates the groups
  for set of ZDD variables (whose cardinality is given by parameter
  multiplicity) that are created for each BDD variable in
  Cudd_zddVarsFromBddVars. The crux of the matter is to determine the index
  each new group. (The index of the first variable in the group.)
  We first build all the groups for the children of a node, and then deal
  with the ZDD variables that are directly attached to the node. The problem
  for these is that the tree itself does not provide information on their
  position inside the group. While we deal with the children of the node,
  therefore, we keep track of all the positions they occupy. The remaining
  positions in the tree can be freely used. Also, we keep track of all the
  variables placed in the children. All the remaining variables are directly
  attached to the group. We can then place any pair of variables not yet
  grouped in any pair of available positions in the node.
<p>

<dd> <b>Side Effects</b> Changes the variable group tree.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddVarsFromBddVars">Cudd_zddVarsFromBddVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="addTriangleRecur"></A>
static DdNode * <I></I>
<B>addTriangleRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int * <b>vars</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addTriangle. Returns
  a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="addVarToConst"></A>
static void <I></I>
<B>addVarToConst</B>(
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  DdNode * <b>one</b>, <i></i>
  DdNode * <b>zero</b> <i></i>
)
</pre>
<dd> Replaces variables with constants if possible (part of
  canonical form).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="addWalshInt"></A>
static DdNode * <I></I>
<B>addWalshInt</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Generates a Walsh matrix in ADD form. Returns a pointer
  to the matrixi if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddWalsh.c"TARGET="ABSTRACT"><CODE>cuddAddWalsh.c</CODE></A>

<dt><pre>
<A NAME="array_compare"></A>
static int <I></I>
<B>array_compare</B>(
  const char * <b>array1</b>, <i></i>
  const char * <b>array2</b> <i></i>
)
</pre>
<dd> Comparison function for the computed table. Returns 0 if
  the two arrays are equal; 1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="array_hash"></A>
static int <I></I>
<B>array_hash</B>(
  char * <b>array</b>, <i></i>
  int  <b>modulus</b> <i></i>
)
</pre>
<dd> Hash function for the computed table. Returns the bucket
  number.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="bddAnnotateMintermCount"></A>
static double <I></I>
<B>bddAnnotateMintermCount</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  double  <b>max</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Annotates every node in the BDD node with its minterm count.
  In this function, every node and the minterm count represented by it are
  stored in a hash table.
<p>

<dd> <b>Side Effects</b> Fills up 'table' with the pair <node,minterm_count>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="bddCheckPositiveCube"></A>
static int <I></I>
<B>bddCheckPositiveCube</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="bddCorrelationAux"></A>
static double <I></I>
<B>bddCorrelationAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCorrelation.
  Returns the fraction of minterms in the ON-set of the EXNOR of f and
  g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddCorrelationWeightsAux">bddCorrelationWeightsAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="bddCorrelationWeightsAux"></A>
static double <I></I>
<B>bddCorrelationWeightsAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  double * <b>prob</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCorrelationWeigths.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddCorrelationAux">bddCorrelationAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="bddFixTree"></A>
static void <I></I>
<B>bddFixTree</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Fixes the BDD variable group tree after a
  shuffle. Assumes that the order of the variables in a terminal node
  has not been changed.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="bddVarToCanonicalSimple"></A>
static int <I></I>
<B>bddVarToCanonicalSimple</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>fp</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  unsigned int * <b>topfp</b>, <i></i>
  unsigned int * <b>topgp</b>, <i></i>
  unsigned int * <b>tophp</b> <i></i>
)
</pre>
<dd> Makes sure the first two pointers are regular.  This
  mat require the complementation of the result, which is signaled by
  returning 1 instead of 0.  This function is simpler than the general
  case because it assumes that no two arguments are the same or
  complementary, and no argument is constant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddVarToConst">bddVarToConst</a>
<a href="#bddVarToCanonical">bddVarToCanonical</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="bddVarToCanonical"></A>
static int <I></I>
<B>bddVarToCanonical</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>fp</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  unsigned int * <b>topfp</b>, <i></i>
  unsigned int * <b>topgp</b>, <i></i>
  unsigned int * <b>tophp</b> <i></i>
)
</pre>
<dd> Reduces 2 variable expressions to canonical form.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddVarToConst">bddVarToConst</a>
<a href="#bddVarToCanonicalSimple">bddVarToCanonicalSimple</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="bddVarToConst"></A>
static void <I></I>
<B>bddVarToConst</B>(
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  DdNode * <b>one</b> <i></i>
)
</pre>
<dd> This function performs part of the transformation to
  standard form by replacing variables with constants if possible.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddVarToCanonical">bddVarToCanonical</a>
<a href="#bddVarToCanonicalSimple">bddVarToCanonicalSimple</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="beforep"></A>
static int <I></I>
<B>beforep</B>(
  DdHalfWord  <b>var1a</b>, <i></i>
  short  <b>phase1a</b>, <i></i>
  DdHalfWord  <b>var1b</b>, <i></i>
  short  <b>phase1b</b>, <i></i>
  DdHalfWord  <b>var2a</b>, <i></i>
  short  <b>phase2a</b>, <i></i>
  DdHalfWord  <b>var2b</b>, <i></i>
  short  <b>phase2b</b> <i></i>
)
</pre>
<dd> Returns true iff the first argument precedes the second
  in the clause order.  A clause precedes another if its first lieral
  precedes the first literal of the other, or if the first literals
  are the same, and its second literal precedes the second literal of
  the other clause.  A literal precedes another if it has a higher
  index, of if it has the same index, but it has lower phase.  Phase 0
  is the positive phase, and it is lower than Phase 1 (negative
  phase).
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#equalp">equalp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorAlloc"></A>
static BitVector * <I></I>
<B>bitVectorAlloc</B>(
  int  <b>size</b> <i></i>
)
</pre>
<dd> Allocates a bit vector.  The parameter size gives the
  number of bits.  This procedure allocates enough long's to hold the
  specified number of bits.  Returns a pointer to the allocated vector
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorClear">bitVectorClear</a>
<a href="#bitVectorFree">bitVectorFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorFree"></A>
static void <I></I>
<B>bitVectorFree</B>(
  BitVector * <b>vector</b> <i></i>
)
</pre>
<dd> Frees a bit vector.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorAlloc">bitVectorAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="build_dd"></A>
static int <I></I>
<B>build_dd</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>num</b>, <i>the index of the individual to be built</i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Builds a DD from a given order.  This procedure also
  sifts the final order and inserts into the array the size in nodes
  of the result. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="char *þstringþ"></A>
 <I></I>
<B>char *þstringþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="char *þstrþpointer to string to use if != NULL"></A>
 <I></I>
<B>char *þstrþpointer to string to use if != NULL</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="checkSymmInfo"></A>
static int <I></I>
<B>checkSymmInfo</B>(
  DdManager * <b>table</b>, <i></i>
  DdHalfWord * <b>symmInfo</b>, <i></i>
  int  <b>index</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Returns 1 if a variable is the one with the highest index
  among those belonging to a symmetry group that are in the top part of
  the BDD.  The top part is given by level.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#initSymmInfo">initSymmInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="computeClausesWithUniverse"></A>
static DdTlcInfo * <I></I>
<B>computeClausesWithUniverse</B>(
  DdTlcInfo * <b>Cres</b>, <i>list of clauses for child</i>
  DdHalfWord  <b>label</b>, <i>variable labeling the current node</i>
  short  <b>phase</b> <i>0 if E child is zero; 1 if T child is zero</i>
)
</pre>
<dd> Computes the two-literal clauses for a node with a zero
  child, given the clauses for its other child and the label of the
  node.  Returns a pointer to a TclInfo structure if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#computeClauses">computeClauses</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="computeClauses"></A>
static DdTlcInfo * <I></I>
<B>computeClauses</B>(
  DdTlcInfo * <b>Tres</b>, <i>list of clauses for T child</i>
  DdTlcInfo * <b>Eres</b>, <i>list of clauses for E child</i>
  DdHalfWord  <b>label</b>, <i>variable labeling the current node</i>
  int  <b>size</b> <i>number of variables in the manager</i>
)
</pre>
<dd> Computes the two-literal clauses for a node given the
  clauses for its children and the label of the node.  Returns a
  pointer to a TclInfo structure if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#computeClausesWithUniverse">computeClausesWithUniverse</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="computeLB"></A>
static int <I></I>
<B>computeLB</B>(
  DdManager * <b>table</b>, <i>manager</i>
  DdHalfWord * <b>order</b>, <i>optimal order for the subset</i>
  int  <b>roots</b>, <i>roots between lower and upper</i>
  int  <b>cost</b>, <i>minimum cost for the subset</i>
  int  <b>lower</b>, <i>lower level to be reordered</i>
  int  <b>upper</b>, <i>upper level to be reordered</i>
  int  <b>level</b> <i>offset for the current top bottom var</i>
)
</pre>
<dd> Computes a lower bound on the size of a BDD from the
  following factors:
  <ul>
  <li> size of the lower part of it;
  <li> size of the part of the upper part not subjected to reordering;
  <li> number of roots in the part of the BDD subjected to reordering;
  <li> variable in the support of the roots in the upper part of the
       BDD subjected to reordering.
  <ul/>
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="computeSavings"></A>
static int <I></I>
<B>computeSavings</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>skip</b>, <i></i>
  ApproxInfo * <b>info</b>, <i></i>
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Counts the nodes that would be eliminated if a given
  node were replaced by zero. This procedure uses a queue passed by
  the caller for efficiency: since the queue is left empty at the
  endof the search, it can be reused as is by the next search. Returns
  the count (always striclty positive) if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>UAmarkNodes
RAmarkNodes
BAmarkNodes
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="copyOrder"></A>
static void <I></I>
<B>copyOrder</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Copies the current variable order to array.
  At the same time inverts the permutation.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="createResult"></A>
static DdNode * <I></I>
<B>createResult</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>index</b>, <i></i>
  unsigned int  <b>phase</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  CUDD_VALUE_TYPE  <b>distance</b> <i></i>
)
</pre>
<dd> Builds a result for cache storage.  Returns a pointer
  to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddClosestCube">cuddBddClosestCube</a>
separateCube
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddAddApplyRecur"></A>
DdNode * <I></I>
<B>cuddAddApplyRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_AOP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addApply. Returns a
  pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAddMonadicApplyRecur">cuddAddMonadicApplyRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="cuddAddBddDoPattern"></A>
DdNode * <I></I>
<B>cuddAddBddDoPattern</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddPattern. Returns a
  pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="cuddAddCmplRecur"></A>
DdNode * <I></I>
<B>cuddAddCmplRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addCmpl. Returns a
  pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addCmpl">Cudd_addCmpl</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddAddComposeRecur"></A>
DdNode * <I></I>
<B>cuddAddComposeRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>proj</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addCompose.
  Returns the composed BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addCompose">Cudd_addCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddConstrainRecur"></A>
DdNode * <I></I>
<B>cuddAddConstrainRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addConstrain.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addConstrain">Cudd_addConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddAddExistAbstractRecur"></A>
DdNode * <I></I>
<B>cuddAddExistAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addExistAbstract.
  Returns the ADD obtained by abstracting the variables of cube from f,
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddAddGeneralVectorComposeRecur"></A>
static DdNode * <I></I>
<B>cuddAddGeneralVectorComposeRecur</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>f</b>, <i>ADD in which to compose</i>
  DdNode ** <b>vectorOn</b>, <i>functions to substitute for x_i</i>
  DdNode ** <b>vectorOff</b>, <i>functions to substitute for x_i'</i>
  int  <b>deepest</b> <i>depth of deepest substitution</i>
)
</pre>
<dd> Performs the recursive step of Cudd_addGeneralVectorCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddIteRecur"></A>
DdNode * <I></I>
<B>cuddAddIteRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addIte(f,g,h).
  Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addIte">Cudd_addIte</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddAddMonadicApplyRecur"></A>
DdNode * <I></I>
<B>cuddAddMonadicApplyRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_MAOP  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addMonadicApply. Returns a
  pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAddApplyRecur">cuddAddApplyRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="cuddAddNegateRecur"></A>
DdNode * <I></I>
<B>cuddAddNegateRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addNegate.
  Returns a pointer to the result.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddNeg.c"TARGET="ABSTRACT"><CODE>cuddAddNeg.c</CODE></A>

<dt><pre>
<A NAME="cuddAddNonSimComposeRecur"></A>
static DdNode * <I></I>
<B>cuddAddNonSimComposeRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b>, <i></i>
  DdNode * <b>key</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  int  <b>lastsub</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addNonSimCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddOrAbstractRecur"></A>
DdNode * <I></I>
<B>cuddAddOrAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addOrAbstract.
  Returns the ADD obtained by abstracting the variables of cube from f,
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddAddOuterSumRecur"></A>
static DdNode * <I></I>
<B>cuddAddOuterSumRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>M</b>, <i></i>
  DdNode * <b>r</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addOuterSum.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="cuddAddPermuteRecur"></A>
static DdNode * <I></I>
<B>cuddAddPermuteRecur</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>node</b>, <i>ADD to be reordered</i>
  int * <b>permut</b> <i>permutation array</i>
)
</pre>
<dd> Recursively puts the ADD in the order given in the
  array permut. Checks for trivial cases to terminate recursion, then
  splits on the children of this node.  Once the solutions for the
  children are obtained, it puts into the current position the node
  from the rest of the ADD that should be here. Then returns this ADD.
  The key here is that the node being visited is NOT put in its proper
  place by this instance, but rather is switched when its proper
  position is reached in the recursion tree.<p>
  The DdNode * that is returned is the same ADD as passed in as node,
  but in the new order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#cuddBddPermuteRecur">cuddBddPermuteRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddRestrictRecur"></A>
DdNode * <I></I>
<B>cuddAddRestrictRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addRestrict.
  Returns the restricted ADD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addRestrict">Cudd_addRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddAddRoundOffRecur"></A>
DdNode * <I></I>
<B>cuddAddRoundOffRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  double  <b>trunc</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addRoundOff.
  Returns a pointer to the result.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddNeg.c"TARGET="ABSTRACT"><CODE>cuddAddNeg.c</CODE></A>

<dt><pre>
<A NAME="cuddAddScalarInverseRecur"></A>
DdNode * <I></I>
<B>cuddAddScalarInverseRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>epsilon</b> <i></i>
)
</pre>
<dd> Returns a pointer to the resulting ADD in case of
  success. Returns NULL if any discriminants smaller than epsilon is
  encountered.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddInv.c"TARGET="ABSTRACT"><CODE>cuddAddInv.c</CODE></A>

<dt><pre>
<A NAME="cuddAddUnivAbstractRecur"></A>
DdNode * <I></I>
<B>cuddAddUnivAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addUnivAbstract.
  Returns the ADD obtained by abstracting the variables of cube from f,
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddAddVectorComposeRecur"></A>
static DdNode * <I></I>
<B>cuddAddVectorComposeRecur</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>f</b>, <i>ADD in which to compose</i>
  DdNode ** <b>vector</b>, <i>functions to substitute</i>
  int  <b>deepest</b> <i>depth of deepest substitution</i>
)
</pre>
<dd> Performs the recursive step of Cudd_addVectorCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAllocNode"></A>
DdNode * <I></I>
<B>cuddAllocNode</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Fast storage allocation for DdNodes in the table. The
  first 4 bytes of a chunk contain a pointer to the next block; the
  rest contains DD_MEM_CHUNK spaces for DdNodes.  Returns a pointer to
  a new node if successful; NULL is memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddAnnealing"></A>
int <I></I>
<B>cuddAnnealing</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Get x, y by random selection. Choose either
  exchange or jump randomly. In case of jump, choose between jump_up
  and jump_down randomly. Do exchange or jump and get optimal case.
  Loop until there is no improvement or temperature reaches
  minimum. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="cuddApaCountMintermAux"></A>
static DdApaNumber <I></I>
<B>cuddApaCountMintermAux</B>(
  DdNode * <b>node</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>max</b>, <i></i>
  DdApaNumber  <b>min</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_ApaCountMinterm.
  It is based on the following identity. Let |f| be the
  number of minterms of f. Then:
  <xmp>
    |f| = (|f0|+|f1|)/2
  </xmp>
  where f0 and f1 are the two cofactors of f.
  Uses the identity <code>|f'| = max - |f|</code>.
  The procedure expects the argument "node" to be a regular pointer, and
  guarantees this condition is met in the recursive calls.
  For efficiency, the result of a call is cached only if the node has
  a reference count greater than 1.
  Returns the number of minterms of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="cuddApaStCountfree"></A>
static enum st_retval <I></I>
<B>cuddApaStCountfree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts
  recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="cuddBddAlignToZdd"></A>
int <I></I>
<B>cuddBddAlignToZdd</B>(
  DdManager * <b>table</b> <i>DD manager</i>
)
</pre>
<dd> Reorders BDD variables according to the order of the
  ZDD variables. This function can be called at the end of ZDD
  reordering to insure that the order of the BDD variables is
  consistent with the order of the ZDD variables. The number of ZDD
  variables must be a multiple of the number of BDD variables. Let
  <code>M</code> be the ratio of the two numbers. cuddBddAlignToZdd
  then considers the ZDD variables from <code>M*i</code> to
  <code>(M+1)*i-1</code> as corresponding to BDD variable
  <code>i</code>.  This function should be normally called from
  Cudd_zddReduceHeap, which clears the cache.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable order for all diagrams and performs
  garbage collection of the BDD unique table.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ShuffleHeap">Cudd_ShuffleHeap</a>
<a href="#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddBddAndAbstractRecur"></A>
DdNode * <I></I>
<B>cuddBddAndAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.
  Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAndAbs.c"TARGET="ABSTRACT"><CODE>cuddAndAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddAndRecur"></A>
DdNode * <I></I>
<B>cuddBddAndRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddAnd by taking
  the conjunction of two BDDs.  Returns a pointer to the result is
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBddBooleanDiffRecur"></A>
DdNode * <I></I>
<B>cuddBddBooleanDiffRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>var</b> <i></i>
)
</pre>
<dd> Performs the recursive steps of Cudd_bddBoleanDiff.
  Returns the BDD obtained by XORing the cofactors of f with respect to
  var if successful; NULL otherwise. Exploits the fact that dF/dx =
  dF'/dx.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddCharToVect"></A>
static DdNode * <I></I>
<B>cuddBddCharToVect</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>x</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCharToVect.
  This function maintains the invariant that f is non-zero.
  Returns the i-th component of the vector if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCharToVect">Cudd_bddCharToVect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClipAndAbsRecur"></A>
static DdNode * <I></I>
<B>cuddBddClipAndAbsRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  int  <b>distance</b>, <i></i>
  int  <b>direction</b> <i></i>
)
</pre>
<dd> Approximates the AND of two BDDs and simultaneously
  abstracts the variables in cube. The variables are existentially
  abstracted.  Returns a pointer to the result is successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClippingAndAbstract">Cudd_bddClippingAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClippingAndAbstract"></A>
DdNode * <I></I>
<B>cuddBddClippingAndAbstract</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  DdNode * <b>cube</b>, <i>cube of variables to be abstracted</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g and
  simultaneously abstracts the variables in cube. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClippingAndAbstract">Cudd_bddClippingAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClippingAndRecur"></A>
static DdNode * <I></I>
<B>cuddBddClippingAndRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int  <b>distance</b>, <i></i>
  int  <b>direction</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddClippingAnd by taking
  the conjunction of two BDDs.  Returns a pointer to the result is
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddClippingAnd">cuddBddClippingAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClippingAnd"></A>
DdNode * <I></I>
<B>cuddBddClippingAnd</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClippingAnd">Cudd_bddClippingAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClosestCube"></A>
DdNode * <I></I>
<B>cuddBddClosestCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  CUDD_VALUE_TYPE  <b>bound</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddClosestCube.
  Returns the cube if succesful; NULL otherwise.  The procedure uses a
  four-way recursion to examine all four combinations of cofactors of
  <code>f</code> and <code>g</code> according to the following formula.
  <pre>
    H(f,g) = min(H(ft,gt), H(fe,ge), H(ft,ge)+1, H(fe,gt)+1)
  </pre>
  Bounding is based on the following observations.
  <ul>
  <li> If we already found two points at distance 0, there is no point in
       continuing.  Furthermore,
  <li> If F == not(G) then the best we can hope for is a minimum distance
       of 1.  If we have already found two points at distance 1, there is
       no point in continuing.  (Indeed, H(F,G) == 1 in this case.  We
       have to continue, though, to find the cube.)
  </ul>
  The variable <code>bound</code> is set at the largest value of the distance
  that we are still interested in.  Therefore, we desist when
  <pre>
    (bound == -1) and (F != not(G)) or (bound == 0) and (F == not(G)).
  </pre>
  If we were maximally aggressive in using the bound, we would always
  set the bound to the minimum distance seen thus far minus one.  That
  is, we would maintain the invariant
  <pre>
    bound < minD,
  </pre>
  except at the very beginning, when we have no value for
  <code>minD</code>.<p>

  However, we do not use <code>bound < minD</code> when examining the
  two negative cofactors, because we try to find a large cube at
  minimum distance.  To do so, we try to find a cube in the negative
  cofactors at the same or smaller distance from the cube found in the
  positive cofactors.<p>

  When we compute <code>H(ft,ge)</code> and <code>H(fe,gt)</code> we
  know that we are going to add 1 to the result of the recursive call
  to account for the difference in the splitting variable.  Therefore,
  we decrease the bound correspondingly.<p>

  Another important observation concerns the need of examining all
  four pairs of cofators only when both <code>f</code> and
  <code>g</code> depend on the top variable.<p>

  Suppose <code>gt == ge == g</code>.  (That is, <code>g</code> does
  not depend on the top variable.)  Then
  <pre>
    H(f,g) = min(H(ft,g), H(fe,g), H(ft,g)+1, H(fe,g)+1)
	   = min(H(ft,g), H(fe,g)) .
  </pre>
  Therefore, under these circumstances, we skip the two "cross" cases.<p>

  An interesting feature of this function is the scheme used for
  caching the results in the global computed table.  Since we have a
  cube and a distance, we combine them to form an ADD.  The
  combination replaces the zero child of the top node of the cube with
  the negative of the distance.  (The use of the negative is to avoid
  ambiguity with 1.)  The degenerate cases (zero and one) are treated
  specially because the distance is known (0 for one, and infinity for
  zero).
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClosestCube">Cudd_bddClosestCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddBddComposeRecur"></A>
DdNode * <I></I>
<B>cuddBddComposeRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>proj</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCompose.
  Exploits the fact that the composition of f' with g
  produces the complement of the composition of f with g to better
  utilize the cache.  Returns the composed BDD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCompose">Cudd_bddCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddConstrainDecomp"></A>
static int <I></I>
<B>cuddBddConstrainDecomp</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>decomp</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddConstrainDecomp.
  Returns f super (i) if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrainDecomp">Cudd_bddConstrainDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddConstrainRecur"></A>
DdNode * <I></I>
<B>cuddBddConstrainRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddConstrain.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddExistAbstractRecur"></A>
DdNode * <I></I>
<B>cuddBddExistAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive steps of Cudd_bddExistAbstract.
  Returns the BDD obtained by abstracting the variables
  of cube from f if successful; NULL otherwise. It is also used by
  Cudd_bddUnivAbstract.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddIntersectRecur"></A>
DdNode * <I></I>
<B>cuddBddIntersectRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddIntersect.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIntersect">Cudd_bddIntersect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBddIsop"></A>
DdNode	* <I></I>
<B>cuddBddIsop</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddIsop.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIsop">Cudd_bddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="cuddBddIteRecur"></A>
DdNode * <I></I>
<B>cuddBddIteRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddIte. Returns a
  pointer to the resulting BDD. NULL if the intermediate result blows
  up or if reordering occurs.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLICBuildResult"></A>
static DdNode * <I></I>
<B>cuddBddLICBuildResult</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>cache</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Builds the results of Cudd_bddLICompaction.
  Returns a pointer to the minimized BDD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
<a href="#cuddBddLICMarkEdges">cuddBddLICMarkEdges</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLICMarkEdges"></A>
static int <I></I>
<B>cuddBddLICMarkEdges</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  st_table * <b>cache</b> <i></i>
)
</pre>
<dd> Performs the edge marking step of Cudd_bddLICompaction.
  Returns the LUB of the markings of the two outgoing edges of <code>f</code>
  if successful; otherwise CUDD_OUT_OF_MEM.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
<a href="#cuddBddLICBuildResult">cuddBddLICBuildResult</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLICompaction"></A>
DdNode * <I></I>
<B>cuddBddLICompaction</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be minimized</i>
  DdNode * <b>c</b> <i>constraint (care set)</i>
)
</pre>
<dd> Performs safe minimization of a BDD. Given the BDD
  <code>f</code> of a function to be minimized and a BDD
  <code>c</code> representing the care set, Cudd_bddLICompaction
  produces the BDD of a function that agrees with <code>f</code>
  wherever <code>c</code> is 1.  Safe minimization means that the size
  of the result is guaranteed not to exceed the size of
  <code>f</code>. This function is based on the DAC97 paper by Hong et
  al..  Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLiteralSetIntersectionRecur"></A>
DdNode * <I></I>
<B>cuddBddLiteralSetIntersectionRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of
  Cudd_bddLiteralSetIntersection. Scans the cubes for common variables,
  and checks whether they agree in phase.  Returns a pointer to the
  resulting cube if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLiteral.c"TARGET="ABSTRACT"><CODE>cuddLiteral.c</CODE></A>

<dt><pre>
<A NAME="cuddBddMakePrime"></A>
DdNode * <I></I>
<B>cuddBddMakePrime</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>cube</b>, <i>cube to be expanded</i>
  DdNode * <b>f</b> <i>function of which the cube is to be made a prime</i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddMakePrime.
  Returns the prime if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="cuddBddNPAndRecur"></A>
DdNode * <I></I>
<B>cuddBddNPAndRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddNPAnd.
  Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddNPAnd">Cudd_bddNPAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddPermuteRecur"></A>
static DdNode * <I></I>
<B>cuddBddPermuteRecur</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>node</b>, <i>BDD to be reordered</i>
  int * <b>permut</b> <i>permutation array</i>
)
</pre>
<dd> Recursively puts the BDD in the order given in the array permut.
  Checks for trivial cases to terminate recursion, then splits on the
  children of this node.  Once the solutions for the children are
  obtained, it puts into the current position the node from the rest of
  the BDD that should be here. Then returns this BDD.
  The key here is that the node being visited is NOT put in its proper
  place by this instance, but rather is switched when its proper position
  is reached in the recursion tree.<p>
  The DdNode * that is returned is the same BDD as passed in as node,
  but in the new order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#cuddAddPermuteRecur">cuddAddPermuteRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddRestrictRecur"></A>
DdNode * <I></I>
<B>cuddBddRestrictRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddRestrict.
  Returns the restricted BDD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddSqueeze"></A>
static DdNode * <I></I>
<B>cuddBddSqueeze</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddSqueeze.  This
  procedure exploits the fact that if we complement and swap the
  bounds of the interval we obtain a valid solution by taking the
  complement of the solution to the original problem. Therefore, we
  can enforce the condition that the upper bound is always regular.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddTransferRecur"></A>
static DdNode * <I></I>
<B>cuddBddTransferRecur</B>(
  DdManager * <b>ddS</b>, <i></i>
  DdManager * <b>ddD</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddTransfer.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddTransfer">cuddBddTransfer</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="cuddBddTransfer"></A>
DdNode * <I></I>
<B>cuddBddTransfer</B>(
  DdManager * <b>ddS</b>, <i></i>
  DdManager * <b>ddD</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD from a manager to another one. Returns a
  pointer to the BDD in the destination manager if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddTransfer">Cudd_bddTransfer</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="cuddBddVarMapRecur"></A>
static DdNode * <I></I>
<B>cuddBddVarMapRecur</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdNode * <b>f</b> <i>BDD to be remapped</i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddVarMap.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddVarMap">Cudd_bddVarMap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddVectorComposeRecur"></A>
static DdNode * <I></I>
<B>cuddBddVectorComposeRecur</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>f</b>, <i>BDD in which to compose</i>
  DdNode ** <b>vector</b>, <i>functions to be composed</i>
  int  <b>deepest</b> <i>depth of the deepest substitution</i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddVectorCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddXorExistAbstractRecur"></A>
DdNode * <I></I>
<B>cuddBddXorExistAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the exclusive OR of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.  Returns a
  pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddXorRecur"></A>
DdNode * <I></I>
<B>cuddBddXorRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddXor by taking
  the exclusive OR of two BDDs.  Returns a pointer to the result is
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddXor">Cudd_bddXor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBiasedUnderApprox"></A>
DdNode * <I></I>
<B>cuddBiasedUnderApprox</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Applies the biased remapping underappoximation algorithm.
  Proceeds in three phases:
  <ul>
  <li> collect information on each node in the BDD; this is done via DFS.
  <li> traverse the BDD in top-down fashion and compute for each node
  whether remapping increases density.
  <li> traverse the BDD via DFS and actually perform the elimination.
  </ul>
  Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_BiasedUnderApprox">Cudd_BiasedUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="cuddCProjectionRecur"></A>
DdNode * <I></I>
<B>cuddCProjectionRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>R</b>, <i></i>
  DdNode * <b>Y</b>, <i></i>
  DdNode * <b>Ysupp</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CProjection. Returns
  the projection if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CProjection">Cudd_CProjection</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheFlush"></A>
void <I></I>
<B>cuddCacheFlush</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Flushes the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheInsert1"></A>
void <I></I>
<B>cuddCacheInsert1</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with two
  operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheInsert">cuddCacheInsert</a>
<a href="#cuddCacheInsert2">cuddCacheInsert2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheInsert2"></A>
void <I></I>
<B>cuddCacheInsert2</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with two
  operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheInsert">cuddCacheInsert</a>
<a href="#cuddCacheInsert1">cuddCacheInsert1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheInsert"></A>
void <I></I>
<B>cuddCacheInsert</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with three
  operands.  The operator tag (see cuddInt.h for details) is split and stored
  into unused bits of the first two pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheInsert2">cuddCacheInsert2</a>
<a href="#cuddCacheInsert1">cuddCacheInsert1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup1Zdd"></A>
DdNode * <I></I>
<B>cuddCacheLookup1Zdd</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookupZdd">cuddCacheLookupZdd</a>
<a href="#cuddCacheLookup2Zdd">cuddCacheLookup2Zdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup1"></A>
DdNode * <I></I>
<B>cuddCacheLookup1</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup">cuddCacheLookup</a>
<a href="#cuddCacheLookup2">cuddCacheLookup2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup2Zdd"></A>
DdNode * <I></I>
<B>cuddCacheLookup2Zdd</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookupZdd">cuddCacheLookupZdd</a>
<a href="#cuddCacheLookup1Zdd">cuddCacheLookup1Zdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup2"></A>
DdNode * <I></I>
<B>cuddCacheLookup2</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup">cuddCacheLookup</a>
<a href="#cuddCacheLookup1">cuddCacheLookup1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookupZdd"></A>
DdNode * <I></I>
<B>cuddCacheLookupZdd</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup2Zdd">cuddCacheLookup2Zdd</a>
<a href="#cuddCacheLookup1Zdd">cuddCacheLookup1Zdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup"></A>
DdNode * <I></I>
<B>cuddCacheLookup</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup2">cuddCacheLookup2</a>
<a href="#cuddCacheLookup1">cuddCacheLookup1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheProfile"></A>
int <I></I>
<B>cuddCacheProfile</B>(
  DdManager * <b>table</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Computes and prints a profile of the cache usage.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheResize"></A>
void <I></I>
<B>cuddCacheResize</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Resizes the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCheckCollisionOrdering"></A>
static int <I></I>
<B>cuddCheckCollisionOrdering</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b>, <i></i>
  int  <b>j</b> <i></i>
)
</pre>
<dd> Checks whether a collision list is ordered.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddClearDeathRow"></A>
void <I></I>
<B>cuddClearDeathRow</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Clears the death row.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="#Cudd_IterDerefBdd">Cudd_IterDerefBdd</a>
<a href="#Cudd_CheckZeroRef">Cudd_CheckZeroRef</a>
<a href="#cuddGarbageCollect">cuddGarbageCollect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddCofactorRecur"></A>
DdNode * <I></I>
<B>cuddCofactorRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_Cofactor. Returns a
  pointer to the cofactor if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Cofactor">Cudd_Cofactor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCof.c"TARGET="ABSTRACT"><CODE>cuddCof.c</CODE></A>

<dt><pre>
<A NAME="cuddCollectNodes"></A>
int <I></I>
<B>cuddCollectNodes</B>(
  DdNode * <b>f</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Traverses the DD f and collects all its nodes in a
  symbol table.  f is assumed to be a regular pointer and
  cuddCollectNodes guarantees this assumption in the recursive calls.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddComputeFloorLog2"></A>
int <I></I>
<B>cuddComputeFloorLog2</B>(
  unsigned int  <b>value</b> <i></i>
)
</pre>
<dd> Returns the floor of the logarithm to the base 2.
  The input value is assumed to be greater than 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddConjunctsAux"></A>
static int <I></I>
<B>cuddConjunctsAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>c1</b>, <i></i>
  DdNode ** <b>c2</b> <i></i>
)
</pre>
<dd> Procedure to compute two conjunctive factors of f and
  place in *c1 and *c2. Sets up the required data - table of distances
  from the constant and local reference count. Also minterm table.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="cuddConstantLookup"></A>
DdNode * <I></I>
<B>cuddConstantLookup</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Looks up in the cache for the result of op applied to f,
  g, and h. Assumes that the calling procedure (e.g.,
  Cudd_bddIteConstant) is only interested in whether the result is
  constant or not. Returns the result if found (possibly
  DD_NON_CONSTANT); otherwise it returns NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup">cuddCacheLookup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddDestroySubtables"></A>
int <I></I>
<B>cuddDestroySubtables</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Destroys the n most recently created subtables in a unique
  table.  n should be positive. The subtables should not contain any live
  nodes, except the (isolated) projection function. The projection
  functions are freed.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The variable map used for fast variable substitution is
  destroyed if it exists. In this case the cache is also cleared.
<p>

<dd> <b>See Also</b> <code><a href="#cuddInsertSubtables">cuddInsertSubtables</a>
<a href="#Cudd_SetVarMap">Cudd_SetVarMap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddDoRebalance"></A>
static void <I></I>
<B>cuddDoRebalance</B>(
  DdNodePtr ** <b>stack</b>, <i></i>
  int  <b>stackN</b> <i></i>
)
</pre>
<dd> Rebalances a red/black tree.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddDynamicAllocNode"></A>
DdNode * <I></I>
<B>cuddDynamicAllocNode</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Dynamically allocates a Node. This procedure is similar
  to cuddAllocNode in Cudd_Table.c, but it does not attempt garbage
  collection, because during reordering there are no dead nodes.
  Returns a pointer to a new node if successful; NULL is memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAllocNode">cuddAllocNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddEstimateCofactorSimple"></A>
static int <I></I>
<B>cuddEstimateCofactorSimple</B>(
  DdNode * <b>node</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CofactorEstimateSimple.
  Returns an estimate of the number of nodes in the DD of the positive
  cofactor of node. Uses the least significant bit of the next field as
  visited flag. node is supposed to be regular; the invariant is maintained
  by this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddEstimateCofactor"></A>
static int <I></I>
<B>cuddEstimateCofactor</B>(
  DdManager * <b>dd</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>i</b>, <i></i>
  int  <b>phase</b>, <i></i>
  DdNode ** <b>ptr</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CofactorEstimate.
  Returns an estimate of the number of nodes in the DD of a
  cofactor of node. Uses the least significant bit of the next field as
  visited flag. node is supposed to be regular; the invariant is maintained
  by this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddExact"></A>
int <I></I>
<B>cuddExact</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Exact variable ordering algorithm. Finds an optimum
  order for the variables between lower and upper.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="cuddFindParent"></A>
static int <I></I>
<B>cuddFindParent</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Searches the subtables above node for a parent. Returns 1
  as soon as one parent is found. Returns 0 is the search is fruitless.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddFreeTable"></A>
void <I></I>
<B>cuddFreeTable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Frees the resources associated to a unique table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddInitTable">cuddInitTable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddGarbageCollect"></A>
int <I></I>
<B>cuddGarbageCollect</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>clearCache</b> <i></i>
)
</pre>
<dd> Performs garbage collection on the BDD and ZDD unique tables.
  If clearCache is 0, the cache is not cleared. This should only be
  specified if the cache has been cleared right before calling
  cuddGarbageCollect. (As in the case of dynamic reordering.)
  Returns the total number of deleted nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddGa"></A>
int <I></I>
<B>cuddGa</B>(
  DdManager * <b>table</b>, <i>manager</i>
  int  <b>lower</b>, <i>lowest level to be reordered</i>
  int  <b>upper</b> <i>highest level to be reorderded</i>
)
</pre>
<dd> Genetic algorithm for DD reordering.
  The two children of a crossover will be stored in
  storedd[popsize
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="cuddGetBranches"></A>
void <I></I>
<B>cuddGetBranches</B>(
  DdNode * <b>g</b>, <i></i>
  DdNode ** <b>g1</b>, <i></i>
  DdNode ** <b>g0</b> <i></i>
)
</pre>
<dd> Computes the children of g.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCof.c"TARGET="ABSTRACT"><CODE>cuddCof.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableGenericInsert"></A>
int <I></I>
<B>cuddHashTableGenericInsert</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  void * <b>value</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is one
  pointer and the value is not a DdNode pointer.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="#cuddHashTableGenericLookup">cuddHashTableGenericLookup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableGenericLookup"></A>
void * <I></I>
<B>cuddHashTableGenericLookup</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of one pointer in a hash
  table when the value is not a DdNode pointer.  Returns the value
  associated to the key if there is an entry for the given key in the
  table; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableGenericInsert">cuddHashTableGenericInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableGenericQuit"></A>
void <I></I>
<B>cuddHashTableGenericQuit</B>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Shuts down a hash table, when the values are not DdNode
  pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInit">cuddHashTableInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInit"></A>
DdHashTable * <I></I>
<B>cuddHashTableInit</B>(
  DdManager * <b>manager</b>, <i></i>
  unsigned int  <b>keySize</b>, <i></i>
  unsigned int  <b>initSize</b> <i></i>
)
</pre>
<dd> Initializes a hash table. Returns a pointer to the new
  table if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableQuit">cuddHashTableQuit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert1"></A>
int <I></I>
<B>cuddHashTableInsert1</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is one pointer.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert2"></A>
int <I></I>
<B>cuddHashTableInsert2</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is
  composed of two pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert3"></A>
int <I></I>
<B>cuddHashTableInsert3</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is
  composed of three pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert"></A>
int <I></I>
<B>cuddHashTableInsert</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNodePtr * <b>key</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key has more than
  three pointers.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>[cuddHashTableInsert1
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="#cuddHashTableLookup">cuddHashTableLookup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup1"></A>
DdNode * <I></I>
<B>cuddHashTableLookup1</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of one pointer in a hash table.
  Returns the value associated to the key if there is an entry for the given
  key in the table; NULL otherwise. If the entry is present, its reference
  counter is decremented if not saturated. If the counter reaches 0, the
  value of the entry is dereferenced, and the entry is returned to the free
  list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup2"></A>
DdNode * <I></I>
<B>cuddHashTableLookup2</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of two pointer in a hash table.
  Returns the value associated to the key if there is an entry for the given
  key in the table; NULL otherwise. If the entry is present, its reference
  counter is decremented if not saturated. If the counter reaches 0, the
  value of the entry is dereferenced, and the entry is returned to the free
  list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup3"></A>
DdNode * <I></I>
<B>cuddHashTableLookup3</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of three pointers in a hash table.
  Returns the value associated to the key if there is an entry for the given
  key in the table; NULL otherwise. If the entry is present, its reference
  counter is decremented if not saturated. If the counter reaches 0, the
  value of the entry is dereferenced, and the entry is returned to the free
  list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup"></A>
DdNode * <I></I>
<B>cuddHashTableLookup</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNodePtr * <b>key</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of more than three pointers
  in a hash table.  Returns the value associated to the key if there
  is an entry for the given key in the table; NULL otherwise. If the
  entry is present, its reference counter is decremented if not
  saturated. If the counter reaches 0, the value of the entry is
  dereferenced, and the entry is returned to the free list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="#cuddHashTableInsert">cuddHashTableInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableQuit"></A>
void <I></I>
<B>cuddHashTableQuit</B>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Shuts down a hash table, dereferencing all the values.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInit">cuddHashTableInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableResize"></A>
static int <I></I>
<B>cuddHashTableResize</B>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Resizes a hash table. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHeapProfile"></A>
int <I></I>
<B>cuddHeapProfile</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Prints to the manager's stdout the number of live nodes for each
  level of the DD heap that contains at least one live node.  It also
  prints a summary containing:
  <ul>
  <li> total number of tables;
  <li> number of tables with live nodes;
  <li> table with the largest number of live nodes;
  <li> number of nodes in that table.
  </ul>
  If more than one table contains the maximum number of live nodes,
  only the one of lowest index is reported. Returns 1 in case of success
  and 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="cuddInitCache"></A>
int <I></I>
<B>cuddInitCache</B>(
  DdManager * <b>unique</b>, <i>unique table</i>
  unsigned int  <b>cacheSize</b>, <i>initial size of the cache</i>
  unsigned int  <b>maxCacheSize</b> <i>cache size beyond which no resizing occurs</i>
)
</pre>
<dd> Initializes the computed table. It is called by
  Cudd_Init. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Init">Cudd_Init</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddInitInteract"></A>
int <I></I>
<B>cuddInitInteract</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Initializes the interaction matrix. The interaction
  matrix is implemented as a bit vector storing the upper triangle of
  the symmetric interaction matrix. The bit vector is kept in an array
  of long integers. The computation is based on a series of depth-first
  searches, one for each root of the DAG. Two flags are needed: The
  local visited flag uses the LSB of the then pointer. The global
  visited flag uses the LSB of the next pointer.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="cuddInitLinear"></A>
int <I></I>
<B>cuddInitLinear</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Initializes the linear transform matrix.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddInitTable"></A>
DdManager * <I></I>
<B>cuddInitTable</B>(
  unsigned int  <b>numVars</b>, <i>Initial number of BDD variables (and subtables)</i>
  unsigned int  <b>numVarsZ</b>, <i>Initial number of ZDD variables (and subtables)</i>
  unsigned int  <b>numSlots</b>, <i>Initial size of the BDD subtables</i>
  unsigned int  <b>looseUpTo</b> <i>Limit for fast table growth</i>
)
</pre>
<dd> Creates and initializes the unique table. Returns a pointer
  to the table if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Init">Cudd_Init</a>
<a href="#cuddFreeTable">cuddFreeTable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddInsertSubtables"></A>
int <I></I>
<B>cuddInsertSubtables</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Inserts n new subtables in a unique table at level.
  The number n should be positive, and level should be an existing level.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddDestroySubtables">cuddDestroySubtables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddIsInDeathRow"></A>
int <I></I>
<B>cuddIsInDeathRow</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Checks whether a node is in the death row. Returns the
  position of the first occurrence if the node is present; -1
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="#cuddClearDeathRow">cuddClearDeathRow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueDequeue"></A>
void <I></I>
<B>cuddLevelQueueDequeue</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Remove an item from the front of a level queue.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueEnqueue"></A>
void * <I></I>
<B>cuddLevelQueueEnqueue</B>(
  DdLevelQueue * <b>queue</b>, <i>level queue</i>
  void * <b>key</b>, <i>key to be enqueued</i>
  int  <b>level</b> <i>level at which to insert</i>
)
</pre>
<dd> Inserts a new key in a level queue. A new entry is
  created in the queue only if the node is not already
  enqueued. Returns a pointer to the queue item if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueInit">cuddLevelQueueInit</a>
<a href="#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueFirst"></A>
void * <I></I>
<B>cuddLevelQueueFirst</B>(
  DdLevelQueue * <b>queue</b>, <i>level queue</i>
  void * <b>key</b>, <i>key to be enqueued</i>
  int  <b>level</b> <i>level at which to insert</i>
)
</pre>
<dd> Inserts the first key in a level queue. Returns a
  pointer to the queue item if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueInit"></A>
DdLevelQueue * <I></I>
<B>cuddLevelQueueInit</B>(
  int  <b>levels</b>, <i>number of levels</i>
  int  <b>itemSize</b>, <i>size of the item</i>
  int  <b>numBuckets</b> <i>initial number of hash buckets</i>
)
</pre>
<dd> Initializes a level queue. A level queue is a queue
  where inserts are based on the levels of the nodes. Within each
  level the policy is FIFO. Level queues are useful in traversing a
  BDD top-down. Queue items are kept in a free list when dequeued for
  efficiency. Returns a pointer to the new queue if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueQuit">cuddLevelQueueQuit</a>
<a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
<a href="#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueQuit"></A>
void <I></I>
<B>cuddLevelQueueQuit</B>(
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Shuts down a level queue and releases all the
  associated memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueInit">cuddLevelQueueInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLinearAndSifting"></A>
int <I></I>
<B>cuddLinearAndSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> BDD reduction based on combination of sifting and linear
  transformations.  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the DD heap. At each position, linear transformation
    of the two adjacent variables is tried and is accepted if it reduces
    the size of the DD.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddLinearInPlace"></A>
int <I></I>
<B>cuddLinearInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Linearly combines two adjacent variables. Specifically,
  replaces the top variable with the exclusive nor of the two variables.
  It assumes that no dead nodes are present on entry to this
  procedure.  The procedure then guarantees that no dead nodes will be
  present when it terminates.  cuddLinearInPlace assumes that x &lt;
  y.  Returns the number of keys in the table if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> The two subtables corrresponding to variables x and y are
  modified. The global counters of the unique table are also affected.
<p>

<dd> <b>See Also</b> <code><a href="#cuddSwapInPlace">cuddSwapInPlace</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheAddToList"></A>
static void <I></I>
<B>cuddLocalCacheAddToList</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Inserts a local cache in the manager list.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheClearAll"></A>
void <I></I>
<B>cuddLocalCacheClearAll</B>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Clears the local caches of a manager.
  Used before reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheClearDead"></A>
void <I></I>
<B>cuddLocalCacheClearDead</B>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Clears the dead entries of the local caches of a manager.
  Used during garbage collection.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheInit"></A>
DdLocalCache * <I></I>
<B>cuddLocalCacheInit</B>(
  DdManager * <b>manager</b>, <i>manager</i>
  unsigned int  <b>keySize</b>, <i>size of the key (number of operands)</i>
  unsigned int  <b>cacheSize</b>, <i>Initial size of the cache</i>
  unsigned int  <b>maxCacheSize</b> <i>Size of the cache beyond which no resizing occurs</i>
)
</pre>
<dd> Initializes a computed table.  Returns a pointer the
  the new local cache in case of success; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddInitCache">cuddInitCache</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheInsert"></A>
void <I></I>
<B>cuddLocalCacheInsert</B>(
  DdLocalCache * <b>cache</b>, <i></i>
  DdNodePtr * <b>key</b>, <i></i>
  DdNode * <b>value</b> <i></i>
)
</pre>
<dd> Inserts a result in a local cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheLookup"></A>
DdNode * <I></I>
<B>cuddLocalCacheLookup</B>(
  DdLocalCache * <b>cache</b>, <i></i>
  DdNodePtr * <b>key</b> <i></i>
)
</pre>
<dd> Looks up in a local cache. Returns the result if found;
  it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheProfile"></A>
int <I></I>
<B>cuddLocalCacheProfile</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Computes and prints a profile of a local cache usage.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheQuit"></A>
void <I></I>
<B>cuddLocalCacheQuit</B>(
  DdLocalCache * <b>cache</b> <i>cache to be shut down</i>
)
</pre>
<dd> Initializes the computed table. It is called by
  Cudd_Init. Returns a pointer the the new local cache in case of
  success; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLocalCacheInit">cuddLocalCacheInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheRemoveFromList"></A>
static void <I></I>
<B>cuddLocalCacheRemoveFromList</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Removes a local cache from the manager list.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheResize"></A>
static void <I></I>
<B>cuddLocalCacheResize</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Resizes a local cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddMakeBddFromZddCover"></A>
DdNode	* <I></I>
<B>cuddMakeBddFromZddCover</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Converts a ZDD cover to a BDD. If successful, it returns
  a BDD node, otherwise it returns NULL. It is a recursive algorithm
  that works as follows. First it computes 3 cofactors of a ZDD cover:
  f1, f0 and fd. Second, it compute BDDs (b1, b0 and bd) of f1, f0 and fd.
  Third, it computes T=b1+bd and E=b0+bd. Fourth, it computes ITE(v,T,E) where
  v is the variable which has the index of the top node of the ZDD cover.
  In this case, since the index of v can be larger than either the one of T
  or the one of E, cuddUniqueInterIVO is called, where IVO stands for
  independent from variable ordering.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MakeBddFromZddCover">Cudd_MakeBddFromZddCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="cuddMinHammingDistRecur"></A>
static int <I></I>
<B>cuddMinHammingDistRecur</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>minterm</b>, <i></i>
  DdHashTable * <b>table</b>, <i></i>
  int  <b>upperBound</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_MinHammingDist.
  It is based on the following identity. Let H(f) be the
  minimum Hamming distance of the minterms of f from the reference
  minterm. Then:
  <xmp>
    H(f) = min(H(f0)+h0,H(f1)+h1)
  </xmp>
  where f0 and f1 are the two cofactors of f with respect to its top
  variable; h0 is 1 if the minterm assigns 1 to the top variable of f;
  h1 is 1 if the minterm assigns 0 to the top variable of f.
  The upper bound on the distance is used to bound the depth of the
  recursion.
  Returns the minimum distance unless it exceeds the upper bound or
  computation fails.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MinHammingDist">Cudd_MinHammingDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddNextHigh"></A>
int <I></I>
<B>cuddNextHigh</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a larger index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddNextLow">cuddNextLow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddNextLow"></A>
int <I></I>
<B>cuddNextLow</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a smaller index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddNextHigh">cuddNextHigh</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddNodeArrayRecur"></A>
static int <I></I>
<B>cuddNodeArrayRecur</B>(
  DdNode * <b>f</b>, <i></i>
  DdNodePtr * <b>table</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Performs the recursive step of cuddNodeArray.  Returns
  an the number of nodes in the DD.  Clear the least significant bit
  of the next field that was used as visited flag by
  cuddNodeArrayRecur when counting the nodes.  node is supposed to be
  regular; the invariant is maintained by this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddNodeArray"></A>
DdNodePtr * <I></I>
<B>cuddNodeArray</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>n</b> <i></i>
)
</pre>
<dd> Traverses the DD f and collects all its nodes in an array.
  The caller should free the array returned by cuddNodeArray.
  Returns a pointer to the array of nodes in case of success; NULL
  otherwise.  The nodes are collected in reverse topological order, so
  that a node is always preceded in the array by all its descendants.
<p>

<dd> <b>Side Effects</b> The number of nodes is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddOrderedInsert"></A>
static void <I></I>
<B>cuddOrderedInsert</B>(
  DdNodePtr * <b>root</b>, <i></i>
  DdNodePtr  <b>node</b> <i></i>
)
</pre>
<dd> Inserts a DdNode in a red/black search tree. Nodes from
  the same "page" (defined by DD_PAGE_MASK) are linked in a LIFO list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddOrderedThread">cuddOrderedThread</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddOrderedThread"></A>
static DdNode * <I></I>
<B>cuddOrderedThread</B>(
  DdNode * <b>root</b>, <i></i>
  DdNode * <b>list</b> <i></i>
)
</pre>
<dd> Threads all the nodes of a search tree into a linear
  list. For each node of the search tree, the "left" child, if non-null, has
  a lower address than its parent, and the "right" child, if non-null, has a
  higher address than its parent.
  The list is sorted in order of increasing addresses. The search
  tree is destroyed as a result of this operation. The last element of
  the linear list is made to point to the address passed in list. Each
  node if the search tree is a linearly-linked list of nodes from the
  same memory page (as defined in DD_PAGE_MASK). When a node is added to
  the linear list, all the elements of the linked list are added.
<p>

<dd> <b>Side Effects</b> The search tree is destroyed as a result of this operation.
<p>

<dd> <b>See Also</b> <code><a href="#cuddOrderedInsert">cuddOrderedInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddPrintNode"></A>
void <I></I>
<B>cuddPrintNode</B>(
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints out information on a node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="cuddPrintVarGroups"></A>
void <I></I>
<B>cuddPrintVarGroups</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  MtrNode * <b>root</b>, <i>root of the group tree</i>
  int  <b>zdd</b>, <i>0: BDD; 1: ZDD</i>
  int  <b>silent</b> <i>flag to check tree syntax only</i>
)
</pre>
<dd> Prints the variable groups as a parenthesized list.
  For each group the level range that it represents is printed. After
  each group, the group's flags are printed, preceded by a `|'.  For
  each flag (except MTR_TERMINAL) a character is printed.
  <ul>
  <li>F: MTR_FIXED
  <li>N: MTR_NEWNODE
  <li>S: MTR_SOFT
  </ul>
  The second argument, silent, if different from 0, causes
  Cudd_PrintVarGroups to only check the syntax of the group tree.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="cuddP"></A>
int <I></I>
<B>cuddP</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Prints a DD to the standard output. One line per node is
  printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddReclaimZdd"></A>
void <I></I>
<B>cuddReclaimZdd</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Brings children of a dead ZDD node back.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddReclaim">cuddReclaim</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddReclaim"></A>
void <I></I>
<B>cuddReclaim</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Brings children of a dead node back.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddReclaimZdd">cuddReclaimZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddRehash"></A>
void <I></I>
<B>cuddRehash</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Doubles the size of a unique subtable and rehashes its
  contents.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddRemapUnderApprox"></A>
DdNode * <I></I>
<B>cuddRemapUnderApprox</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Applies the remapping underappoximation algorithm.
  Proceeds in three phases:
  <ul>
  <li> collect information on each node in the BDD; this is done via DFS.
  <li> traverse the BDD in top-down fashion and compute for each node
  whether remapping increases density.
  <li> traverse the BDD via DFS and actually perform the elimination.
  </ul>
  Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RemapUnderApprox">Cudd_RemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="cuddResizeLinear"></A>
int <I></I>
<B>cuddResizeLinear</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Resizes the linear transform matrix.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddResizeTableZdd"></A>
int <I></I>
<B>cuddResizeTableZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Increases the number of ZDD subtables in a unique table so
  that it meets or exceeds index.  When new ZDD variables are created, it
  is possible to preserve the functions unchanged, or it is possible to
  preserve the covers unchanged, but not both. cuddResizeTableZdd preserves
  the covers.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddResizeTable">ddResizeTable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddSetInteract"></A>
void <I></I>
<B>cuddSetInteract</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Given a pair of variables 0 <= x < y < table->size,
  sets the corresponding bit of the interaction matrix to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="cuddShrinkDeathRow"></A>
void <I></I>
<B>cuddShrinkDeathRow</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Shrinks the death row by a factor of four.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddClearDeathRow">cuddClearDeathRow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddShrinkSubtable"></A>
void <I></I>
<B>cuddShrinkSubtable</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Shrinks a subtable.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRehash">cuddRehash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddSifting"></A>
int <I></I>
<B>cuddSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of Rudell's sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddSlowTableGrowth"></A>
void <I></I>
<B>cuddSlowTableGrowth</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Adjusts parameters of a table to slow down its growth.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddSolveEqnRecur"></A>
DdNode * <I></I>
<B>cuddSolveEqnRecur</B>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode * <b>Y</b>, <i>the cube of remaining y variables</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int  <b>n</b>, <i>number of unknowns</i>
  int * <b>yIndex</b>, <i>array holding the y variable indices</i>
  int  <b>i</b> <i>level of recursion</i>
)
</pre>
<dd> Implements the recursive step of Cudd_SolveEqn. 
  Returns NULL if the intermediate solution blows up
  or reordering occurs. The parametric solutions are
  stored in the array G.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SolveEqn">Cudd_SolveEqn</a>
<a href="#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSolve.c"TARGET="ABSTRACT"><CODE>cuddSolve.c</CODE></A>

<dt><pre>
<A NAME="cuddSplitSetRecur"></A>
DdNode* <I></I>
<B>cuddSplitSetRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>mtable</b>, <i></i>
  int * <b>varSeen</b>, <i></i>
  DdNode * <b>p</b>, <i></i>
  double  <b>n</b>, <i></i>
  double  <b>max</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_SplitSet. The
  procedure recursively traverses the BDD and checks to see if any
  node satisfies the minterm requirements as specified by 'n'. At any
  node X, n is compared to the number of minterms in the onset of X's
  children. If either of the child nodes have exactly n minterms, then
  that node is returned; else, if n is greater than the onset of one
  of the child nodes, that node is retained and the difference in the
  number of minterms is extracted from the other child. In case n
  minterms can be extracted from constant 1, the algorithm returns the
  result with at most log(n) nodes.
<p>

<dd> <b>Side Effects</b> The array 'varSeen' is updated at every recursive call
  to set the variables traversed by the procedure.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="cuddStCountfree"></A>
enum st_retval <I></I>
<B>cuddStCountfree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts
  recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddSubsetHeavyBranch"></A>
DdNode * <I></I>
<B>cuddSubsetHeavyBranch</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b> <i>threshold size for the subset</i>
)
</pre>
<dd> Here a subset BDD is built by throwing away one of the
  children. Starting at root, annotate each node with the number of
  minterms (in terms of the total number of variables specified -
  numVars), number of nodes taken by the DAG rooted at this node and
  number of additional nodes taken by the child that has the lesser
  minterms. The child with the lower number of minterms is thrown away
  and a dyanmic count of the nodes of the subset is kept. Once the
  threshold is reached the subset is returned to the calling
  procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="cuddSubsetShortPaths"></A>
DdNode * <I></I>
<B>cuddSubsetShortPaths</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>total number of variables in consideration</i>
  int  <b>threshold</b>, <i>maximum number of nodes allowed in the subset</i>
  int  <b>hardlimit</b> <i>flag determining whether threshold should be respected strictly</i>
)
</pre>
<dd> The outermost procedure to return a subset of the given
  BDD with the largest cubes. The path lengths are calculated, the maximum
  allowable path length is determined and the number of nodes of this
  path length that can be used to build a subset. If the threshold is
  larger than the size of the original BDD, the original BDD is
  returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="cuddSwapInPlace"></A>
int <I></I>
<B>cuddSwapInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps two adjacent variables. It assumes that no dead
  nodes are present on entry to this procedure.  The procedure then
  guarantees that no dead nodes will be present when it terminates.
  cuddSwapInPlace assumes that x &lt; y.  Returns the number of keys in
  the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddSwapping"></A>
int <I></I>
<B>cuddSwapping</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  Cudd_ReorderingType  <b>heuristic</b> <i></i>
)
</pre>
<dd> Implementation of Plessier's algorithm that reorders
  variables by a sequence of (non-adjacent) swaps.
    <ol>
    <li> Select two variables (RANDOM or HEURISTIC).
    <li> Permute these variables.
    <li> If the nodes have decreased accept the permutation.
    <li> Otherwise reconstruct the original heap.
    <li> Loop.
    </ol>
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddSymmCheck"></A>
int <I></I>
<B>cuddSymmCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for symmetry of x and y. Ignores projection
  functions, unless they are isolated. Returns 1 in case of symmetry; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="cuddSymmSiftingConv"></A>
int <I></I>
<B>cuddSymmSiftingConv</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting to convergence algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the DD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    <li> Repeat 1-4 until no further improvement.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddSymmSifting">cuddSymmSifting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="cuddSymmSifting"></A>
int <I></I>
<B>cuddSymmSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the DD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddSymmSiftingConv">cuddSymmSiftingConv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="cuddTestInteract"></A>
int <I></I>
<B>cuddTestInteract</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Given a pair of variables 0 <= x < y < table->size,
  tests whether the corresponding bit of the interaction matrix is 1.
  Returns the value of the bit.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="cuddTimesInDeathRow"></A>
int <I></I>
<B>cuddTimesInDeathRow</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Counts how many times a node is in the death row.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="#cuddClearDeathRow">cuddClearDeathRow</a>
<a href="#cuddIsInDeathRow">cuddIsInDeathRow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddTreeSifting"></A>
int <I></I>
<B>cuddTreeSifting</B>(
  DdManager * <b>table</b>, <i>DD table</i>
  Cudd_ReorderingType  <b>method</b> <i>reordering method for the groups of leaves</i>
)
</pre>
<dd> Tree sifting algorithm. Assumes that a tree representing
  a group hierarchy is passed as a parameter. It then reorders each
  group in postorder fashion by calling ddTreeSiftingAux.  Assumes that
  no dead nodes are present.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="cuddUnderApprox"></A>
DdNode * <I></I>
<B>cuddUnderApprox</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Applies Tom Shiple's underappoximation algorithm. Proceeds
  in three phases:
  <ul>
  <li> collect information on each node in the BDD; this is done via DFS.
  <li> traverse the BDD in top-down fashion and compute for each node
  whether its elimination increases density.
  <li> traverse the BDD via DFS and actually perform the elimination.
  </ul>
  Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_UnderApprox">Cudd_UnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueConst"></A>
DdNode * <I></I>
<B>cuddUniqueConst</B>(
  DdManager * <b>unique</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of a constant node.
  If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  Returns a
  pointer to the new node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueInterIVO"></A>
DdNode * <I></I>
<B>cuddUniqueInterIVO</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInter that is independent of
  variable ordering (IVO). This function does not require parameter
  index to precede the indices of the top nodes of T and E in the
  variable order.  Returns a pointer to the result node under normal
  conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInter">cuddUniqueInter</a>
<a href="#Cudd_MakeBddFromZddCover">Cudd_MakeBddFromZddCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueInterZdd"></A>
DdNode * <I></I>
<B>cuddUniqueInterZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal
  ZDD node. If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  For a newly
  created node, increments the reference counts of what T and E point
  to.  Returns a pointer to the new node if successful; NULL if memory
  is exhausted or if reordering took place.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInter">cuddUniqueInter</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueInter"></A>
DdNode * <I></I>
<B>cuddUniqueInter</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal
  node. If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  For a newly
  created node, increments the reference counts of what T and E point
  to.  Returns a pointer to the new node if successful; NULL if memory
  is exhausted or if reordering took place.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInterZdd">cuddUniqueInterZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueLookup"></A>
static DdNode * <I></I>
<B>cuddUniqueLookup</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal
  node. Returns a pointer to the node if it is in the table; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInter">cuddUniqueInter</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddUpdateInteractionMatrix"></A>
void <I></I>
<B>cuddUpdateInteractionMatrix</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>xindex</b>, <i></i>
  int  <b>yindex</b> <i></i>
)
</pre>
<dd> Updates the interaction matrix.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddVerifySol"></A>
DdNode * <I></I>
<B>cuddVerifySol</B>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int * <b>yIndex</b>, <i>array holding the y variable indices</i>
  int  <b>n</b> <i>number of unknowns</i>
)
</pre>
<dd> Implements the recursive step of Cudd_VerifySol.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSolve.c"TARGET="ABSTRACT"><CODE>cuddSolve.c</CODE></A>

<dt><pre>
<A NAME="cuddWindowReorder"></A>
int <I></I>
<B>cuddWindowReorder</B>(
  DdManager * <b>table</b>, <i>DD table</i>
  int  <b>low</b>, <i>lowest index to reorder</i>
  int  <b>high</b>, <i>highest index to reorder</i>
  Cudd_ReorderingType  <b>submethod</b> <i>window reordering option</i>
)
</pre>
<dd> Reorders by applying the method of the sliding window.
  Tries all possible permutations to the variables in a window that
  slides from low to high. The size of the window is determined by
  submethod.  Assumes that no dead nodes are present.  Returns 1 in
  case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="cuddXorLinear"></A>
static void <I></I>
<B>cuddXorLinear</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> XORs two rows of the linear transform matrix and replaces
  the first row with the result.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddZddAlignToBdd"></A>
int <I></I>
<B>cuddZddAlignToBdd</B>(
  DdManager * <b>table</b> <i>DD manager</i>
)
</pre>
<dd> Reorders ZDD variables according to the order of the
  BDD variables. This function can be called at the end of BDD
  reordering to insure that the order of the ZDD variables is
  consistent with the order of the BDD variables. The number of ZDD
  variables must be a multiple of the number of BDD variables. Let
  <code>M</code> be the ratio of the two numbers. cuddZddAlignToBdd
  then considers the ZDD variables from <code>M*i</code> to
  <code>(M+1)*i-1</code> as corresponding to BDD variable
  <code>i</code>.  This function should be normally called from
  Cudd_ReduceHeap, which clears the cache.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable order for all diagrams and performs
  garbage collection of the ZDD unique table.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddShuffleHeap">Cudd_zddShuffleHeap</a>
<a href="#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddChangeAux"></A>
DdNode * <I></I>
<B>cuddZddChangeAux</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddChange.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddChange"></A>
DdNode * <I></I>
<B>cuddZddChange</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Substitutes a variable with its complement in a ZDD.
  returns a pointer to the result if successful; NULL
  otherwise. cuddZddChange performs the same function as
  Cudd_zddChange, but does not restart if reordering has taken
  place. Therefore it can be called from within a recursive
  procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddChange">Cudd_zddChange</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddComplement"></A>
DdNode	* <I></I>
<B>cuddZddComplement</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes the complement of a ZDD node. So far, since we
  couldn't find a direct way to get the complement of a ZDD cover, we first
  convert a ZDD cover to a BDD, then make the complement of the ZDD cover
  from the complement of the BDD node by using ISOP.
<p>

<dd> <b>Side Effects</b> The result depends on current variable order.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddCountDoubleStep"></A>
static double <I></I>
<B>cuddZddCountDoubleStep</B>(
  DdNode * <b>P</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  DdNode * <b>base</b>, <i></i>
  DdNode * <b>empty</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddCountDouble.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="cuddZddCountStep"></A>
static int <I></I>
<B>cuddZddCountStep</B>(
  DdNode * <b>P</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  DdNode * <b>base</b>, <i></i>
  DdNode * <b>empty</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddCount.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDagInt"></A>
static int <I></I>
<B>cuddZddDagInt</B>(
  DdNode * <b>n</b>, <i></i>
  st_table * <b>tab</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDagSize. Does
  not check for out-of-memory conditions.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddMisc.c"TARGET="ABSTRACT"><CODE>cuddZddMisc.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDiff"></A>
DdNode * <I></I>
<B>cuddZddDiff</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDiff.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDivideF"></A>
DdNode	* <I></I>
<B>cuddZddDivideF</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDivideF.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDivideF">Cudd_zddDivideF</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDivide"></A>
DdNode	* <I></I>
<B>cuddZddDivide</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDivide.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDivide">Cudd_zddDivide</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddFreeUniv"></A>
void <I></I>
<B>cuddZddFreeUniv</B>(
  DdManager * <b>zdd</b> <i></i>
)
</pre>
<dd> Frees the ZDD universe.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddInitUniv">cuddZddInitUniv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInit.c"TARGET="ABSTRACT"><CODE>cuddInit.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetCofactors2"></A>
int <I></I>
<B>cuddZddGetCofactors2</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>v</b>, <i></i>
  DdNode ** <b>f1</b>, <i></i>
  DdNode ** <b>f0</b> <i></i>
)
</pre>
<dd> Computes the two-way decomposition of f w.r.t. v.
<p>

<dd> <b>Side Effects</b> The results are returned in f1 and f0.
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddGetCofactors3">cuddZddGetCofactors3</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetCofactors3"></A>
int <I></I>
<B>cuddZddGetCofactors3</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>v</b>, <i></i>
  DdNode ** <b>f1</b>, <i></i>
  DdNode ** <b>f0</b>, <i></i>
  DdNode ** <b>fd</b> <i></i>
)
</pre>
<dd> Computes the three-way decomposition of function f (represented
  by a ZDD) wit respect to variable v.  Returns 0 if successful; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The results are returned in f1, f0, and fd.
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddGetCofactors2">cuddZddGetCofactors2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNegVarIndex"></A>
int <I></I>
<B>cuddZddGetNegVarIndex</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the index of negative ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNegVarLevel"></A>
int <I></I>
<B>cuddZddGetNegVarLevel</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the level of negative ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNodeIVO"></A>
DdNode * <I></I>
<B>cuddZddGetNodeIVO</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInterZdd that is independent of
  variable ordering (IVO). This function does not require parameter
  index to precede the indices of the top nodes of g and h in the
  variable order.  Returns a pointer to the result node under normal
  conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddGetNode">cuddZddGetNode</a>
<a href="#cuddZddIsop">cuddZddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNode"></A>
DdNode * <I></I>
<B>cuddZddGetNode</B>(
  DdManager * <b>zdd</b>, <i></i>
  int  <b>id</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInterZdd, which applies the ZDD
  reduction rule. Returns a pointer to the result node under normal
  conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInterZdd">cuddUniqueInterZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetPosVarIndex"></A>
int <I></I>
<B>cuddZddGetPosVarIndex</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the index of positive ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetPosVarLevel"></A>
int <I></I>
<B>cuddZddGetPosVarLevel</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the level of positive ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddInitUniv"></A>
int <I></I>
<B>cuddZddInitUniv</B>(
  DdManager * <b>zdd</b> <i></i>
)
</pre>
<dd> Initializes the ZDD universe. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddFreeUniv">cuddZddFreeUniv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInit.c"TARGET="ABSTRACT"><CODE>cuddInit.c</CODE></A>

<dt><pre>
<A NAME="cuddZddIntersect"></A>
DdNode * <I></I>
<B>cuddZddIntersect</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIntersect.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddIsop"></A>
DdNode	* <I></I>
<B>cuddZddIsop</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b>, <i></i>
  DdNode ** <b>zdd_I</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIsop.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddIsop">Cudd_zddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddIte"></A>
DdNode * <I></I>
<B>cuddZddIte</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIte.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearAux"></A>
static int <I></I>
<B>cuddZddLinearAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearBackward"></A>
static int <I></I>
<B>cuddZddLinearBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>size</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearDown"></A>
static Move * <I></I>
<B>cuddZddLinearDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable down. Moves x down until either it
  reaches the bound (xHigh) or the size of the ZDD heap increases too
  much. Returns the set of moves in case of success; NULL if memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearInPlace"></A>
static int <I></I>
<B>cuddZddLinearInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Linearly combines two adjacent variables. It assumes
  that no dead nodes are present on entry to this procedure.  The
  procedure then guarantees that no dead nodes will be present when it
  terminates.  cuddZddLinearInPlace assumes that x &lt; y.  Returns the
  number of keys in the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSwapInPlace">cuddZddSwapInPlace</a>
<a href="#cuddLinearInPlace">cuddLinearInPlace</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearSifting"></A>
int <I></I>
<B>cuddZddLinearSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of the linear sifting algorithm for ZDDs.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down and applies the XOR transformation,
    remembering each time the total size of the DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearUp"></A>
static Move * <I></I>
<B>cuddZddLinearUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable up applying the XOR
  transformation. Moves y up until either it reaches the bound (xLow)
  or the size of the ZDD heap increases too much.  Returns the set of
  moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddNextHigh"></A>
int <I></I>
<B>cuddZddNextHigh</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a larger index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddNextLow"></A>
int <I></I>
<B>cuddZddNextLow</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a smaller index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddProduct"></A>
DdNode	* <I></I>
<B>cuddZddProduct</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddProduct.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddProduct">Cudd_zddProduct</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddP"></A>
int <I></I>
<B>cuddZddP</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Prints a ZDD to the standard output. One line per node is
  printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingAux"></A>
static int <I></I>
<B>cuddZddSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingBackward"></A>
static int <I></I>
<B>cuddZddSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingDown"></A>
static Move * <I></I>
<B>cuddZddSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Sifts a variable down. Moves x down until either it
  reaches the bound (x_high) or the size of the ZDD heap increases too
  much. Returns the set of moves in case of success; NULL if memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingUp"></A>
static Move * <I></I>
<B>cuddZddSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Sifts a variable up. Moves y up until either it reaches
  the bound (x_low) or the size of the ZDD heap increases too much.
  Returns the set of moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSifting"></A>
int <I></I>
<B>cuddZddSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of Rudell's sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSubset0"></A>
DdNode * <I></I>
<B>cuddZddSubset0</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the negative cofactor of a ZDD w.r.t. a
  variable. In terms of combinations, the result is the set of all
  combinations in which the variable is negated. Returns a pointer to
  the result if successful; NULL otherwise. cuddZddSubset0 performs
  the same function as Cudd_zddSubset0, but does not restart if
  reordering has taken place. Therefore it can be called from within a
  recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSubset1">cuddZddSubset1</a>
<a href="#Cudd_zddSubset0">Cudd_zddSubset0</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSubset1"></A>
DdNode * <I></I>
<B>cuddZddSubset1</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the positive cofactor of a ZDD w.r.t. a
  variable. In terms of combinations, the result is the set of all
  combinations in which the variable is asserted. Returns a pointer to
  the result if successful; NULL otherwise. cuddZddSubset1 performs
  the same function as Cudd_zddSubset1, but does not restart if
  reordering has taken place. Therefore it can be called from within a
  recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSubset0">cuddZddSubset0</a>
<a href="#Cudd_zddSubset1">Cudd_zddSubset1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSwapInPlace"></A>
int <I></I>
<B>cuddZddSwapInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps two adjacent variables. It assumes that no dead
  nodes are present on entry to this procedure.  The procedure then
  guarantees that no dead nodes will be present when it terminates.
  cuddZddSwapInPlace assumes that x &lt; y.  Returns the number of keys in
  the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSwapping"></A>
int <I></I>
<B>cuddZddSwapping</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  Cudd_ReorderingType  <b>heuristic</b> <i></i>
)
</pre>
<dd> Implementation of Plessier's algorithm that reorders
  variables by a sequence of (non-adjacent) swaps.
    <ol>
    <li> Select two variables (RANDOM or HEURISTIC).
    <li> Permute these variables.
    <li> If the nodes have decreased accept the permutation.
    <li> Otherwise reconstruct the original heap.
    <li> Loop.
    </ol>
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmCheck"></A>
int <I></I>
<B>cuddZddSymmCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for symmetry of x and y. Ignores projection
  functions, unless they are isolated. Returns 1 in case of
  symmetry; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingAux"></A>
static int <I></I>
<B>cuddZddSymmSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b> <i></i>
)
</pre>
<dd> Given x_low <= x <= x_high moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is not part of a symmetry group. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingBackward"></A>
static int <I></I>
<B>cuddZddSymmSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingConvAux"></A>
static int <I></I>
<B>cuddZddSymmSiftingConvAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b> <i></i>
)
</pre>
<dd> Given x_low <= x <= x_high moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is either an isolated variable, or it is the bottom of
  a symmetry group. All symmetries may not have been found, because of
  exceeded growth limit. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingConv"></A>
int <I></I>
<B>cuddZddSymmSiftingConv</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting to convergence algorithm for ZDDs.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the ZDD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    <li> Repeat 1-4 until no further improvement.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSymmSifting">cuddZddSymmSifting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSifting_down"></A>
static Move * <I></I>
<B>cuddZddSymmSifting_down</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Moves x down until either it reaches the bound (x_high)
  or the size of the ZDD heap increases too much. Assumes that x is the
  bottom of a symmetry group. Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; ZDD_MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSifting_up"></A>
static Move * <I></I>
<B>cuddZddSymmSifting_up</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Moves x up until either it reaches the bound (x_low) or
  the size of the ZDD heap increases too much. Assumes that x is the top
  of a symmetry group.  Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; ZDD_MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSifting"></A>
int <I></I>
<B>cuddZddSymmSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the ZDD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSymmSiftingConv">cuddZddSymmSiftingConv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSummary"></A>
static void <I></I>
<B>cuddZddSymmSummary</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  int * <b>symvars</b>, <i></i>
  int * <b>symgroups</b> <i></i>
)
</pre>
<dd> Counts numbers of symmetric variables and symmetry
  groups.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddTreeSifting"></A>
int <I></I>
<B>cuddZddTreeSifting</B>(
  DdManager * <b>table</b>, <i>DD table</i>
  Cudd_ReorderingType  <b>method</b> <i>reordering method for the groups of leaves</i>
)
</pre>
<dd> Tree sifting algorithm for ZDDs. Assumes that a tree
  representing a group hierarchy is passed as a parameter. It then
  reorders each group in postorder fashion by calling
  zddTreeSiftingAux.  Assumes that no dead nodes are present.  Returns
  1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUnateProduct"></A>
DdNode	* <I></I>
<B>cuddZddUnateProduct</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddUnateProduct.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddUnateProduct">Cudd_zddUnateProduct</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUndoMoves"></A>
static Move* <I></I>
<B>cuddZddUndoMoves</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  order in effect before the moves.  Returns 1 in case of success;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUnion"></A>
DdNode * <I></I>
<B>cuddZddUnion</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddUnion.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUniqueCompare"></A>
int <I></I>
<B>cuddZddUniqueCompare</B>(
  int * <b>ptr_x</b>, <i></i>
  int * <b>ptr_y</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddWeakDivF"></A>
DdNode	* <I></I>
<B>cuddZddWeakDivF</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddWeakDivF.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddWeakDivF">Cudd_zddWeakDivF</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddWeakDiv"></A>
DdNode	* <I></I>
<B>cuddZddWeakDiv</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddWeakDiv.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="ddBddMaximallyExpand"></A>
static DdNode * <I></I>
<B>ddBddMaximallyExpand</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>lb</b>, <i>cube to be expanded</i>
  DdNode * <b>ub</b>, <i>upper bound cube</i>
  DdNode * <b>f</b> <i>function against which to expand</i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddMaximallyExpand.
  Returns set of primes or zero BDD if successful; NULL otherwise.  On entry
  to this function, ub and lb should be different from the zero BDD.  The
  function then maintains this invariant.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="ddBddShortestPathUnate"></A>
static int <I></I>
<B>ddBddShortestPathUnate</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>phases</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs shortest path computation on a unate function.
  Returns the length of the shortest path to one if successful;
  CUDD_OUT_OF_MEM otherwise.  This function is based on the observation
  that in the BDD of a unate function no node except the constant is
  reachable from the root via paths of different parity.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#getShortest">getShortest</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="ddBddToAddRecur"></A>
static DdNode * <I></I>
<B>ddBddToAddRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_BddToAdd. Returns a
  pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="ddCheckPermuation"></A>
static int <I></I>
<B>ddCheckPermuation</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>perm</b>, <i></i>
  int * <b>invperm</b> <i></i>
)
</pre>
<dd> Checks the BDD variable group tree before a shuffle.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddClearFlag"></A>
static void <I></I>
<B>ddClearFlag</B>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs a DFS from f, clearing the LSB of the next
  pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddSupportStep">ddSupportStep</a>
<a href="#ddFindSupport">ddFindSupport</a>
<a href="#ddLeavesInt">ddLeavesInt</a>
<a href="#ddDagInt">ddDagInt</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddClearGlobal"></A>
static void <I></I>
<B>ddClearGlobal</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>maxlevel</b> <i></i>
)
</pre>
<dd> Scans the DD and clears the LSB of the next pointers.
  The LSB of the next pointers are used as markers to tell whether a
  node was reached. Once the roots are counted, these flags are
  reset.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddCountRoots">ddCountRoots</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddClearGlobal"></A>
static void <I></I>
<B>ddClearGlobal</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> The LSB of the next pointers are used as markers to tell
  whether a node was reached by at least one DFS. Once the interaction
  matrix is built, these flags are reset.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddClearLocal"></A>
static void <I></I>
<B>ddClearLocal</B>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs a DFS from f, clearing the LSB of the then pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddClearVars"></A>
static void <I></I>
<B>ddClearVars</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>SP</b> <i></i>
)
</pre>
<dd> Clears visited flags for variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCofMintermAux"></A>
static double * <I></I>
<B>ddCofMintermAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Traverses the DD node and computes the fraction of
  minterms in the on-set of all positive cofactors simultaneously.
  It allocates an array with two more entries than there are
  variables below the one labeling the node.  One extra entry (the
  first in the array) is for the variable labeling the node. The other
  entry (the last one in the array) holds the fraction of minterms of
  the function rooted at node.  Each other entry holds the value for
  one cofactor. The array is put in a symbol table, to avoid repeated
  computation, and its address is returned by the procedure, for use
  by the caller.  Returns a pointer to the array of cofactor measures.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSign.c"TARGET="ABSTRACT"><CODE>cuddSign.c</CODE></A>

<dt><pre>
<A NAME="ddCountInternalMtrNodes"></A>
static int <I></I>
<B>ddCountInternalMtrNodes</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Counts the number of internal nodes of the group tree.
  Returns the count.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddCountMintermAux"></A>
static double <I></I>
<B>ddCountMintermAux</B>(
  DdNode * <b>node</b>, <i></i>
  double  <b>max</b>, <i></i>
  DdHashTable * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountMinterm.
  It is based on the following identity. Let |f| be the
  number of minterms of f. Then:
  <xmp>
    |f| = (|f0|+|f1|)/2
  </xmp>
  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.  Returns the number of minterms of the function rooted at
  node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCountPathAux"></A>
static double <I></I>
<B>ddCountPathAux</B>(
  DdNode * <b>node</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountPath.
  It is based on the following identity. Let |f| be the
  number of paths of f. Then:
  <xmp>
    |f| = |f0|+|f1|
  </xmp>
  where f0 and f1 are the two cofactors of f.  Uses the
  identity |f'| = |f|, to improve the utilization of the (local) cache.
  Returns the number of paths of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCountPathsToNonZero"></A>
static double <I></I>
<B>ddCountPathsToNonZero</B>(
  DdNode * <b>N</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountPathsToNonZero.
  It is based on the following identity. Let |f| be the
  number of paths of f. Then:
  <xmp>
    |f| = |f0|+|f1|
  </xmp>
  where f0 and f1 are the two cofactors of f.  Returns the number of
  paths of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCountRoots"></A>
static int <I></I>
<B>ddCountRoots</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Counts the number of roots at the levels between lower and
  upper.  The computation is based on breadth-first search.
  A node is a root if it is not reachable from any previously visited node.
  (All the nodes at level lower are therefore considered roots.)
  The visited flag uses the LSB of the next pointer.  Returns the root
  count. The roots that are constant nodes are always ignored.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddClearGlobal">ddClearGlobal</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddCreateGroup"></A>
static void <I></I>
<B>ddCreateGroup</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Creates a group encompassing variables from x to y in the
  DD table. In the current implementation it must be y == x+1.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddDagInt"></A>
static int <I></I>
<B>ddDagInt</B>(
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DagSize. Returns the
  number of nodes in the graph rooted at n.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddDissolveGroup"></A>
static void <I></I>
<B>ddDissolveGroup</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> x and y are variables in a group to be cut in two. The cut
  is to pass between x and y.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpBlif"></A>
static int <I></I>
<B>ddDoDumpBlif</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  char ** <b>names</b>, <i></i>
  int  <b>mv</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DumpBlif. Traverses
  the BDD f and writes a multiplexer-network description to the file
  pointed by fp in blif format. f is assumed to be a regular pointer
  and ddDoDumpBlif guarantees this assumption in the recursive calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpDDcal"></A>
static int <I></I>
<B>ddDoDumpDDcal</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  char ** <b>names</b>, <i></i>
  ptruint  <b>mask</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DumpDDcal. Traverses
  the BDD f and writes a line for each node to the file
  pointed by fp in DDcal format. f is assumed to be a regular pointer
  and ddDoDumpDDcal guarantees this assumption in the recursive calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpDaVinci"></A>
static int <I></I>
<B>ddDoDumpDaVinci</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  char ** <b>names</b>, <i></i>
  ptruint  <b>mask</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DumpDaVinci. Traverses
  the BDD f and writes a term expression to the file
  pointed by fp in daVinci format. f is assumed to be a regular pointer
  and ddDoDumpDaVinci guarantees this assumption in the recursive calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpFactoredForm"></A>
static int <I></I>
<B>ddDoDumpFactoredForm</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  char ** <b>names</b> <i></i>
)
</pre>
<dd> Performs the recursive step of
  Cudd_DumpFactoredForm. Traverses the BDD f and writes a factored
  form for each node to the file pointed by fp in terms of the
  factored forms of the children. Constants are propagated, and
  absorption is applied.  f is assumed to be a regular pointer and
  ddDoDumpFActoredForm guarantees this assumption in the recursive
  calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddEpdCountMintermAux"></A>
static int <I></I>
<B>ddEpdCountMintermAux</B>(
  DdNode * <b>node</b>, <i></i>
  EpDouble * <b>max</b>, <i></i>
  EpDouble * <b>epd</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_EpdCountMinterm.
  It is based on the following identity. Let |f| be the
  number of minterms of f. Then:
  <xmp>
    |f| = (|f0|+|f1|)/2
  </xmp>
  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.  Returns the number of minterms of the function rooted at
  node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddEpdFree"></A>
static enum st_retval <I></I>
<B>ddEpdFree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts
  recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddExchange"></A>
static int <I></I>
<B>ddExchange</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> This is the same funcion as ddSwapping except for
  comparison expression.  Use probability function, exp(-size_change/temp).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddExtSymmCheck"></A>
static int <I></I>
<B>ddExtSymmCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for extended symmetry of x and y. Returns 1 in
  case of extended symmetry; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddFindEssentialRecur"></A>
static DdNode * <I></I>
<B>ddFindEssentialRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_FindEssential.
  Returns a pointer to the cube BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="ddFindNodeHiLo"></A>
static void <I></I>
<B>ddFindNodeHiLo</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>lower</b>, <i></i>
  int * <b>upper</b> <i></i>
)
</pre>
<dd> Finds the lower and upper bounds of the group
  represented by treenode.  From the index and size fields we need to
  derive the current positions, and find maximum and minimum.
<p>

<dd> <b>Side Effects</b> The bounds are returned as side effects.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddFindSupport"></A>
static void <I></I>
<B>ddFindSupport</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>SP</b> <i></i>
)
</pre>
<dd> Recursively find the support of f.  This function uses the
  LSB of the next field of the nodes of f as visited flag.  It also uses the
  LSB of the next field of the variables as flag to remember whether a
  certain index has already been seen.  Finally, it uses the manager stack
  to record all seen indices.
<p>

<dd> <b>Side Effects</b> The stack pointer SP is modified by side-effect.  The next
  fields are changed and need to be reset.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddFindTwoLiteralClausesRecur"></A>
static DdTlcInfo * <I></I>
<B>ddFindTwoLiteralClausesRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Implements the recursive step of
  Cudd_FindTwoLiteralClauses.  The DD node is assumed to be not
  constant.  Returns a pointer to a set of clauses if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FindTwoLiteralClauses">Cudd_FindTwoLiteralClauses</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="ddGetLargestCubeUnate"></A>
static DdNode * <I></I>
<B>ddGetLargestCubeUnate</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>phases</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Extracts largest prime of a unate function.  Returns the BDD of
  the prime if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#getPath">getPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="ddGroupMoveBackward"></A>
static int <I></I>
<B>ddGroupMoveBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap two groups.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupMove"></A>
static int <I></I>
<B>ddGroupMove</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups and records the move. Returns the
  number of keys in the DD table in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingAux"></A>
static int <I></I>
<B>ddGroupSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  int  <b>lazyFlag</b> <i></i>
)
</pre>
<dd> Sifts one variable up and down until it has taken all
  positions. Checks for aggregation. There may be at most two sweeps,
  even if the group grows.  Assumes that x is either an isolated
  variable, or it is the bottom of a group. All groups may not have
  been found. The variable being moved is returned to the best position
  seen during sifting.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingBackward"></A>
static int <I></I>
<B>ddGroupSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b>, <i></i>
  int  <b>upFlag</b>, <i></i>
  int  <b>lazyFlag</b> <i></i>
)
</pre>
<dd> Determines the best position for a variables and returns
  it there.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingDown"></A>
static int <I></I>
<B>ddGroupSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts down a variable until it reaches position xHigh.
  Assumes that x is the bottom of a group (or a singleton).  Records
  all the moves.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingUp"></A>
static int <I></I>
<B>ddGroupSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts up a variable until either it reaches position
  xLow or the size of the DD heap increases too much. Assumes that y is
  the top of a group (or a singleton).  Checks y for aggregation to the
  adjacent variables. Records all the moves that are appended to the
  list of moves received as input and returned as a side effect.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSifting"></A>
static int <I></I>
<B>ddGroupSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  int  <b>lazyFlag</b> <i></i>
)
</pre>
<dd> Sifts from treenode->low to treenode->high. If
  croupcheck == CUDD_GROUP_CHECK7, it checks for group creation at the
  end of the initial sifting. If a group is created, it is then sifted
  again. After sifting one variable, the group that contains it is
  dissolved.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddIsVarHandled"></A>
static int <I></I>
<B>ddIsVarHandled</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variables is already handled. This
  function is used for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddJumpingAux"></A>
static int <I></I>
<B>ddJumpingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> If x==x_low, it executes jumping_down. If x==x_high, it
  executes jumping_up. This funcion is similar to ddSiftingAux. Returns
  1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddJumpingDown"></A>
static Move * <I></I>
<B>ddJumpingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> This is a simplified version of ddSiftingDown. It does not
  use lower bounding. Returns the set of moves in case of success; NULL
  if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddJumpingUp"></A>
static Move * <I></I>
<B>ddJumpingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> This is a simplified version of ddSiftingUp. It does not
  use lower bounding. Returns the set of moves in case of success; NULL
  if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddLeavesInt"></A>
static int <I></I>
<B>ddLeavesInt</B>(
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountLeaves. Returns
  the number of leaves in the DD rooted at n.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CountLeaves">Cudd_CountLeaves</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingAux"></A>
static int <I></I>
<B>ddLinearAndSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. At each step a linear transformation is tried, and, if it
  decreases the size of the DD, it is accepted. Finds the best position
  and does the required changes.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingBackward"></A>
static int <I></I>
<B>ddLinearAndSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>size</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingDown"></A>
static Move * <I></I>
<B>ddLinearAndSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable down and applies linear
  transformations. Moves x down until either it reaches the bound
  (xHigh) or the size of the DD heap increases too much. Returns the
  set of moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingUp"></A>
static Move * <I></I>
<B>ddLinearAndSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable up and applies linear transformations.
  Moves y up until either it reaches the bound (xLow) or the size of
  the DD heap increases too much.  Returns the set of moves in case of
  success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearUniqueCompare"></A>
static int <I></I>
<B>ddLinearUniqueCompare</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddMergeGroups"></A>
static void <I></I>
<B>ddMergeGroups</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Creates a single group from low to high and adjusts the
  index field of the tree node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddNoCheck"></A>
static int <I></I>
<B>ddNoCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Pretends to check two variables for aggregation. Always
  returns 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddPatchTree"></A>
static void <I></I>
<B>ddPatchTree</B>(
  DdManager * <b>dd</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Fixes a variable tree after the insertion of new subtables.
  After such an insertion, the low fields of the tree below the insertion
  point are inconsistent.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddPermuteWindow3"></A>
static int <I></I>
<B>ddPermuteWindow3</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Tries all the permutations of the three variables between
  x and x+2 and retains the best. Assumes that no dead nodes are
  present.  Returns the index of the best permutation (1-6) in case of
  success; 0 otherwise.Assumes that no dead nodes are present.  Returns
  the index of the best permutation (1-6) in case of success; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddPermuteWindow4"></A>
static int <I></I>
<B>ddPermuteWindow4</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>w</b> <i></i>
)
</pre>
<dd> Tries all the permutations of the four variables between
  w and w+3 and retains the best. Assumes that no dead nodes are
  present.  Returns the index of the best permutation (1-24) in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddPickArbitraryMinterms"></A>
static int <I></I>
<B>ddPickArbitraryMinterms</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  int  <b>nminterms</b>, <i></i>
  char ** <b>string</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddPickArbitraryMinterms.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPickArbitraryMinterms">Cudd_bddPickArbitraryMinterms</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddPickRepresentativeCube"></A>
static int <I></I>
<B>ddPickRepresentativeCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  double * <b>weight</b>, <i></i>
  char * <b>string</b> <i></i>
)
</pre>
<dd> Finds a representative cube of a BDD with the weight of
  each variable. From the top variable, if the weight is greater than or
  equal to 0.0, choose THEN branch unless the child is the constant 0.
  Otherwise, choose ELSE branch unless the child is the constant 0.
<p>

<dd> <b>Side Effects</b> Cudd_SubsetWithMaskVars Cudd_bddPickOneCube
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddPrintMintermAux"></A>
static void <I></I>
<B>ddPrintMintermAux</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int * <b>list</b> <i>current recursion path</i>
)
</pre>
<dd> Performs the recursive step of Cudd_PrintMinterm.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddRehashZdd"></A>
static void <I></I>
<B>ddRehashZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Rehashes a ZDD unique subtable.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRehash">cuddRehash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddReorderChildren"></A>
static int <I></I>
<B>ddReorderChildren</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Reorders the children of a group tree node according to
  the options. After reordering puts all the variables in the group
  and/or its descendents in a single group. This allows hierarchical
  reordering.  If the variables in the group do not exist yet, simply
  does nothing. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddReorderPostprocess"></A>
static int <I></I>
<B>ddReorderPostprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Cleans up at the end of reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddReorderPreprocess"></A>
static int <I></I>
<B>ddReorderPreprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prepares the DD heap for dynamic reordering. Does
  garbage collection, to guarantee that there are no dead nodes;
  clears the cache, which is invalidated by dynamic reordering; initializes
  the number of isolated projection functions; and initializes the
  interaction matrix.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddReportRefMess"></A>
static void <I></I>
<B>ddReportRefMess</B>(
  DdManager * <b>unique</b>, <i>manager</i>
  int  <b>i</b>, <i>table in which the problem occurred</i>
  const char * <b>caller</b> <i>procedure that detected the problem</i>
)
</pre>
<dd> Reports problem in garbage collection.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddGarbageCollect">cuddGarbageCollect</a>
<a href="#cuddGarbageCollectZdd">cuddGarbageCollectZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddResetVarHandled"></A>
static int <I></I>
<B>ddResetVarHandled</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Resets a variable to be processed. This function is used
  for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddResizeTable"></A>
static int <I></I>
<B>ddResizeTable</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  int  <b>amount</b> <i></i>
)
</pre>
<dd> Increases the number of subtables in a unique table so
  that it meets or exceeds index.  The parameter amount determines how
  much spare space is allocated to prevent too frequent resizing.  If
  index is negative, the table is resized, but no new variables are
  created.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Reserve">Cudd_Reserve</a>
<a href="#cuddResizeTableZdd">cuddResizeTableZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddSecDiffCheck"></A>
static int <I></I>
<B>ddSecDiffCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks two variables for aggregation. The check is based
  on the second difference of the number of nodes as a function of the
  layer. If the second difference is lower than a given threshold
  (typically negative) then the two variables should be aggregated.
  Returns 1 if the two variables pass the test; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddSetVarHandled"></A>
static int <I></I>
<B>ddSetVarHandled</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to already handled. This function is used
  for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddShuffle"></A>
static int <I></I>
<B>ddShuffle</B>(
  DdManager * <b>table</b>, <i></i>
  DdHalfWord * <b>permutation</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Reorders variables according to a given permutation.
  The i-th permutation array contains the index of the variable that
  should be brought to the i-th level. ddShuffle assumes that no
  dead nodes are present and that the interaction matrix is properly
  initialized.  The reordering is achieved by a series of upward sifts.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddShuffle"></A>
static int <I></I>
<B>ddShuffle</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>permutation</b> <i></i>
)
</pre>
<dd> Reorders variables according to a given permutation.
  The i-th permutation array contains the index of the variable that
  should be brought to the i-th level. ddShuffle assumes that no
  dead nodes are present and that the interaction matrix is properly
  initialized.  The reordering is achieved by a series of upward sifts.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftUp"></A>
static int <I></I>
<B>ddSiftUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Takes a variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.
  Returns 1 if successful; 0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddSiftUp"></A>
static int <I></I>
<B>ddSiftUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Takes a variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.
  Returns 1 if successful; 0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingAux"></A>
static int <I></I>
<B>ddSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingBackward"></A>
static int <I></I>
<B>ddSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>size</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingDown"></A>
static Move * <I></I>
<B>ddSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Sifts a variable down. Moves x down until either it
  reaches the bound (xHigh) or the size of the DD heap increases too
  much. Returns the set of moves in case of success; NULL if memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingUp"></A>
static Move * <I></I>
<B>ddSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Sifts a variable up. Moves y up until either it reaches
  the bound (xLow) or the size of the DD heap increases too much.
  Returns the set of moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSuppInteract"></A>
static void <I></I>
<B>ddSuppInteract</B>(
  DdNode * <b>f</b>, <i></i>
  char * <b>support</b> <i></i>
)
</pre>
<dd> Performs a DFS from f. Uses the LSB of the then pointer
  as visited flag.
<p>

<dd> <b>Side Effects</b> Accumulates in support the variables on which f depends.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddSupportStep"></A>
static void <I></I>
<B>ddSupportStep</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>support</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_Support. Performs a
  DFS from f. The support is accumulated in supp as a side effect. Uses
  the LSB of the then pointer as visited flag.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddClearFlag">ddClearFlag</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddSwapAny"></A>
static Move * <I></I>
<B>ddSwapAny</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps any two variables. Returns the set of moves.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSymmGroupMoveBackward"></A>
static int <I></I>
<B>ddSymmGroupMoveBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap of two groups. x is assumed to be the
  bottom variable of the first group. y is assumed to be the top
  variable of the second group.  Returns the number of keys in the table
  if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmGroupMove"></A>
static int <I></I>
<B>ddSymmGroupMove</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups. x is assumed to be the bottom variable
  of the first group. y is assumed to be the top variable of the second
  group.  Updates the list of moves. Returns the number of keys in the
  table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingAux"></A>
static int <I></I>
<B>ddSymmSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is not part of a symmetry group. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingBackward"></A>
static int <I></I>
<B>ddSymmSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingConvAux"></A>
static int <I></I>
<B>ddSymmSiftingConvAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is either an isolated variable, or it is the bottom of
  a symmetry group. All symmetries may not have been found, because of
  exceeded growth limit. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingDown"></A>
static Move * <I></I>
<B>ddSymmSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Moves x down until either it reaches the bound (xHigh)
  or the size of the DD heap increases too much. Assumes that x is the
  bottom of a symmetry group. Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingUp"></A>
static Move * <I></I>
<B>ddSymmSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Moves x up until either it reaches the bound (xLow) or
  the size of the DD heap increases too much. Assumes that x is the top
  of a symmetry group.  Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSummary"></A>
static void <I></I>
<B>ddSymmSummary</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  int * <b>symvars</b>, <i></i>
  int * <b>symgroups</b> <i></i>
)
</pre>
<dd> Counts numbers of symmetric variables and symmetry
  groups.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmUniqueCompare"></A>
static int <I></I>
<B>ddSymmUniqueCompare</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddTreeSiftingAux"></A>
static int <I></I>
<B>ddTreeSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Recursively visits the group tree and reorders each
  group in postorder fashion.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddUndoMoves"></A>
static Move* <I></I>
<B>ddUndoMoves</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  order in effect before the moves.  Returns 1 in case of success;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddUniqueCompareGroup"></A>
static int <I></I>
<B>ddUniqueCompareGroup</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.  Returns the
  difference in number of keys between the two variables being
  compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddUniqueCompare"></A>
static int <I></I>
<B>ddUniqueCompare</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddUpdateInteract"></A>
static void <I></I>
<B>ddUpdateInteract</B>(
  DdManager * <b>table</b>, <i></i>
  char * <b>support</b> <i></i>
)
</pre>
<dd> If support[i
<p>

<dd> <b>Side Effects</b> Clears support.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddUpdateMtrTree"></A>
static int <I></I>
<B>ddUpdateMtrTree</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>perm</b>, <i></i>
  int * <b>invperm</b> <i></i>
)
</pre>
<dd> Updates the BDD variable group tree before a shuffle.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddVarGroupCheck"></A>
static int <I></I>
<B>ddVarGroupCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for grouping of x and y. Returns 1 in
  case of grouping; 0 otherwise. This function is used for lazy sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddWindow2"></A>
static int <I></I>
<B>ddWindow2</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by applying a sliding window of width 2.
  Tries both permutations of the variables in a window
  that slides from low to high.  Assumes that no dead nodes are
  present.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindow3"></A>
static int <I></I>
<B>ddWindow3</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by applying a sliding window of width 3.
  Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindow4"></A>
static int <I></I>
<B>ddWindow4</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by applying a sliding window of width 4.
  Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindowConv2"></A>
static int <I></I>
<B>ddWindowConv2</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by repeatedly applying a sliding window of width
  2. Tries both permutations of the variables in a window
  that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindowConv3"></A>
static int <I></I>
<B>ddWindowConv3</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by repeatedly applying a sliding window of width
  3. Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindowConv4"></A>
static int <I></I>
<B>ddWindowConv4</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by repeatedly applying a sliding window of width
  4. Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="debugCheckParent"></A>
static void <I></I>
<B>debugCheckParent</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Searches all the subtables above node. Very expensive.
  The same check is now implemented more efficiently in ddDebugCheck.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#debugFindParent">debugFindParent</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="debugFindParent"></A>
static void <I></I>
<B>debugFindParent</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Searches the subtables above node for its parents.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="double *þprobþ"></A>
 <I></I>
<B>double *þprobþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þmgþ"></A>
 <I></I>
<B>double þmgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þmgþ"></A>
 <I></I>
<B>double þmgþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þmþ"></A>
 <I></I>
<B>double þmþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þquality0þminimum improvement for accepted changes when b=0"></A>
 <I></I>
<B>double þquality0þminimum improvement for accepted changes when b=0</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þquality0þminimum improvement for accepted changes when b=0"></A>
 <I></I>
<B>double þquality0þminimum improvement for accepted changes when b=0</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þqualityþminimum improvement for accepted changes"></A>
 <I></I>
<B>double þqualityþminimum improvement for accepted changes</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þqualityþminimum improvement for accepted changes"></A>
 <I></I>
<B>double þqualityþminimum improvement for accepted changes</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þqualityþminimum improvement for accepted changes"></A>
 <I></I>
<B>double þqualityþminimum improvement for accepted changes</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="double þqualityþminimum improvement for accepted changes"></A>
 <I></I>
<B>double þqualityþminimum improvement for accepted changes</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="dp2"></A>
static int <I></I>
<B>dp2</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>t</b> <i></i>
)
</pre>
<dd> Performs the recursive step of cuddP. Returns 1 in case
  of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="emptyClauseSet"></A>
static DdTlcInfo * <I></I>
<B>emptyClauseSet</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns a pointer to an empty set of clauses if
  successful; NULL otherwise.  No bit vector for the phases is
  allocated.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="equalp"></A>
static int <I></I>
<B>equalp</B>(
  DdHalfWord  <b>var1a</b>, <i></i>
  short  <b>phase1a</b>, <i></i>
  DdHalfWord  <b>var1b</b>, <i></i>
  short  <b>phase1b</b>, <i></i>
  DdHalfWord  <b>var2a</b>, <i></i>
  short  <b>phase2a</b>, <i></i>
  DdHalfWord  <b>var2b</b>, <i></i>
  short  <b>phase2b</b> <i></i>
)
</pre>
<dd> Returns true iff the two arguments are identical
  clauses.  Since literals are sorted, we only need to compare
  literals in the same position.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#beforep">beforep</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="find_best"></A>
static int <I></I>
<B>find_best</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the index of the fittest individual.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="fixVarTree"></A>
static void <I></I>
<B>fixVarTree</B>(
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>perm</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Fixes a variable group tree.
<p>

<dd> <b>Side Effects</b> Changes the variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="freeMatrix"></A>
static void <I></I>
<B>freeMatrix</B>(
  DdHalfWord ** <b>matrix</b> <i></i>
)
</pre>
<dd> Frees a two-dimensional matrix allocated by getMatrix.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#getMatrix">getMatrix</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="freePathPair"></A>
static enum st_retval <I></I>
<B>freePathPair</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the entries of the visited symbol table. Returns
  ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="gatherInfoAux"></A>
static NodeData * <I></I>
<B>gatherInfoAux</B>(
  DdNode * <b>node</b>, <i>function to analyze</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>parity</b> <i>gather parity information</i>
)
</pre>
<dd> Recursively counts minterms and computes reference
  counts of each node in the BDD.  Similar to the cuddCountMintermAux
  which recursively counts the number of minterms for the dag rooted
  at each node in terms of the total number of variables (max). It assumes
  that the node pointer passed to it is regular and it maintains the
  invariant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#gatherInfo">gatherInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="gatherInfo"></A>
static ApproxInfo * <I></I>
<B>gatherInfo</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>function to be analyzed</i>
  int  <b>numVars</b>, <i>number of variables node depends on</i>
  int  <b>parity</b> <i>gather parity information</i>
)
</pre>
<dd> Counts minterms and computes reference counts of each
  node in the BDD. The minterm count is separately computed for the
  node and its complement. This is to avoid cancellation
  errors. Returns a pointer to the data structure holding the
  information gathered if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
<a href="#gatherInfoAux">gatherInfoAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="gcd"></A>
static int <I></I>
<B>gcd</B>(
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Returns the gcd of two integers. Uses the binary GCD
  algorithm described in Cormen, Leiserson, and Rivest.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getCube"></A>
static DdNode * <I></I>
<B>getCube</B>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>cost</b> <i></i>
)
</pre>
<dd> Build a BDD for a largest cube of f.
  Given the minimum length from the root, and the minimum
  lengths for each node (in visited), apply triangulation at each node.
  Of the two children of each node on a shortest path, at least one is
  on a shortest path. In case of ties the procedure chooses the THEN
  children.
  Returns a pointer to the cube BDD representing the path if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="getLargest"></A>
static cuddPathPair <I></I>
<B>getLargest</B>(
  DdNode * <b>root</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Finds the size of the largest cube(s) in a DD.
  This problem is translated into finding the shortest paths from a node
  when both THEN and ELSE arcs have unit lengths.
  Uses a local symbol table to store the lengths for each
  node. Only the lengths for the regular nodes are entered in the table,
  because those for the complement nodes are simply obtained by swapping
  the two lenghts.
  Returns a pair of lengths: the length of the shortest path to 1;
  and the length of the shortest path to 0. This is done so as to take
  complement arcs into account.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="getLevelKeys"></A>
static int <I></I>
<B>getLevelKeys</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>l</b> <i></i>
)
</pre>
<dd> Returns the number of nodes at one level of a unique table.
  The projection function, if isolated, is not counted.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getMatrix"></A>
static DdHalfWord ** <I></I>
<B>getMatrix</B>(
  int  <b>rows</b>, <i>number of rows</i>
  int  <b>cols</b> <i>number of columns</i>
)
</pre>
<dd> Allocates a two-dimensional matrix of ints.
  Returns the pointer to the matrix if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#freeMatrix">freeMatrix</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getMaxBinomial"></A>
static int <I></I>
<B>getMaxBinomial</B>(
  int  <b>n</b> <i></i>
)
</pre>
<dd> Computes the maximum value of (n choose k) for a given
  n.  The maximum value occurs for k = n/2 when n is even, or k =
  (n-1)/2 when n is odd.  The algorithm used in this procedure avoids
  intermediate overflow problems.  It is based on the identity
  <pre>
    binomial(n,k) = n/k * binomial(n-1,k-1).
  </pre>
  Returns the computed value if successful; -1 if out of range.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getPath"></A>
static DdNode * <I></I>
<B>getPath</B>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>weight</b>, <i></i>
  int  <b>cost</b> <i></i>
)
</pre>
<dd> Build a BDD for a shortest path of f.
  Given the minimum length from the root, and the minimum
  lengths for each node (in visited), apply triangulation at each node.
  Of the two children of each node on a shortest path, at least one is
  on a shortest path. In case of ties the procedure chooses the THEN
  children.
  Returns a pointer to the cube BDD representing the path if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="getShortest"></A>
static cuddPathPair <I></I>
<B>getShortest</B>(
  DdNode * <b>root</b>, <i></i>
  int * <b>cost</b>, <i></i>
  int * <b>support</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Finds the length of the shortest path(s) in a DD.
  Uses a local symbol table to store the lengths for each
  node. Only the lengths for the regular nodes are entered in the table,
  because those for the complement nodes are simply obtained by swapping
  the two lenghts.
  Returns a pair of lengths: the length of the shortest path to 1;
  and the length of the shortest path to 0. This is done so as to take
  complement arcs into account.
<p>

<dd> <b>Side Effects</b> Accumulates the support of the DD in support.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="hashDelete"></A>
static void <I></I>
<B>hashDelete</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  DdQueueItem * <b>item</b> <i></i>
)
</pre>
<dd> Removes an item from the hash table of a level queue.
  Nothing is done if the item is not in the table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
<a href="#hashInsert">hashInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="hashInsert"></A>
static int <I></I>
<B>hashInsert</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  DdQueueItem * <b>item</b> <i></i>
)
</pre>
<dd> Inserts an item in the hash table of a level queue. Returns
  1 if successful; 0 otherwise. No check is performed to see if an item with
  the same key is already in the hash table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="hashLookup"></A>
static DdQueueItem * <I></I>
<B>hashLookup</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  void * <b>key</b> <i></i>
)
</pre>
<dd> Looks up a key in the hash table of a level queue. Returns
  a pointer to the item with the given key if the key is found; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
<a href="#hashInsert">hashInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="hashResize"></A>
static int <I></I>
<B>hashResize</B>(
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Resizes the hash table of a level queue. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#hashInsert">hashInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="impliedp"></A>
static int <I></I>
<B>impliedp</B>(
  DdHalfWord  <b>var1</b>, <i></i>
  short  <b>phase1</b>, <i></i>
  DdHalfWord  <b>var2</b>, <i></i>
  short  <b>phase2</b>, <i></i>
  BitVector * <b>olv</b>, <i></i>
  BitVector * <b>olp</b> <i></i>
)
</pre>
<dd> Returns true iff either literal of a clause is in a set
  of literals.  The first four arguments specify the clause.  The
  remaining two arguments specify the literal set.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="indexCompare"></A>
static int <I></I>
<B>indexCompare</B>(
  const void * <b>a</b>, <i></i>
  const void * <b>b</b> <i></i>
)
</pre>
<dd> Compares indices for qsort.  Subtracting these integers
  cannot produce overflow, because they are non-negative.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="initSymmInfo"></A>
static DdHalfWord * <I></I>
<B>initSymmInfo</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Translates the symmetry information stored in the next
  field of each subtable from level to indices. This procedure is called
  immediately after symmetric sifting, so that the next fields are correct.
  By translating this informaton in terms of indices, we make it independent
  of subsequent reorderings. The format used is that of the next fields:
  a circular list where each variable points to the next variable in the
  same symmetry group. Only the entries between lower and upper are
  considered.  The procedure returns a pointer to an array
  holding the symmetry information if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#checkSymmInfo">checkSymmInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="int **þcubeþ"></A>
 <I></I>
<B>int **þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int **þcubeþ"></A>
 <I></I>
<B>int **þcubeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int **þindicesþarray containing (on return) the indices"></A>
 <I></I>
<B>int **þindicesþarray containing (on return) the indices</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int **þindicesþarray containing (on return) the indices"></A>
 <I></I>
<B>int **þindicesþarray containing (on return) the indices</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int **þpathþ"></A>
 <I></I>
<B>int **þpathþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int **þpathþ"></A>
 <I></I>
<B>int **þpathþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þarrayþ"></A>
 <I></I>
<B>int *þarrayþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þarrayþ"></A>
 <I></I>
<B>int *þarrayþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þdigitsþ"></A>
 <I></I>
<B>int *þdigitsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þdistanceþ"></A>
 <I></I>
<B>int *þdistanceþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þinputsþ"></A>
 <I></I>
<B>int *þinputsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þlengthþ"></A>
 <I></I>
<B>int *þlengthþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þlengthþ"></A>
 <I></I>
<B>int *þlengthþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þpermutationþrequired variable permutation"></A>
 <I></I>
<B>int *þpermutationþrequired variable permutation</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þpermutationþrequired variable permutation"></A>
 <I></I>
<B>int *þpermutationþrequired variable permutation</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þpermutþ"></A>
 <I></I>
<B>int *þpermutþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þpermutþ"></A>
 <I></I>
<B>int *þpermutþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þphase2þ"></A>
 <I></I>
<B>int *þphase2þ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int *þweightþ"></A>
 <I></I>
<B>int *þweightþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þNþ"></A>
 <I></I>
<B>int þNþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þamountþ"></A>
 <I></I>
<B>int þamountþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þarcviolationþ"></A>
 <I></I>
<B>int þarcviolationþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þbinaryDigitsþ"></A>
 <I></I>
<B>int þbinaryDigitsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þbitþ"></A>
 <I></I>
<B>int þbitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þbitþ"></A>
 <I></I>
<B>int þbitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þcycleþ"></A>
 <I></I>
<B>int þcycleþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þdigitsþ"></A>
 <I></I>
<B>int þdigitsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þdirectionþunder (0) or over (1) approximation"></A>
 <I></I>
<B>int þdirectionþunder (0) or over (1) approximation</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þdirectionþunder (0) or over (1) approximation"></A>
 <I></I>
<B>int þdirectionþunder (0) or over (1) approximation</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þhardlimitþflag: 1 if threshold is a hard limit"></A>
 <I></I>
<B>int þhardlimitþflag: 1 if threshold is a hard limit</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þhardlimitþflag: 1 if threshold is a hard limit"></A>
 <I></I>
<B>int þhardlimitþflag: 1 if threshold is a hard limit</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþ"></A>
 <I></I>
<B>int þindexþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þindexþvariable index"></A>
 <I></I>
<B>int þindexþvariable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þiþ"></A>
 <I></I>
<B>int þiþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þkþnumber of minterms to find"></A>
 <I></I>
<B>int þkþnumber of minterms to find</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þlevelþ"></A>
 <I></I>
<B>int þlevelþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þlevelþ"></A>
 <I></I>
<B>int þlevelþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þminsizeþbound below which no reordering occurs"></A>
 <I></I>
<B>int þminsizeþbound below which no reordering occurs</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þminsizeþbound below which no reordering occurs"></A>
 <I></I>
<B>int þminsizeþbound below which no reordering occurs</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þmultiplicityþhow many ZDD variables are created for each BDD variable"></A>
 <I></I>
<B>int þmultiplicityþhow many ZDD variables are created for each BDD variable</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þmvarsþsize of <code>maskVars</code>"></A>
 <I></I>
<B>int þmvarsþsize of <code>maskVars</code></B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þmvþ0: blif, 1: blif-MV"></A>
 <I></I>
<B>int þmvþ0: blif, 1: blif-MV</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þmvþ0: blif, 1: blif-MV"></A>
 <I></I>
<B>int þmvþ0: blif, 1: blif-MV</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnVarsþ"></A>
 <I></I>
<B>int þnVarsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnumberXoversþ"></A>
 <I></I>
<B>int þnumberXoversþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnvarsþ"></A>
 <I></I>
<B>int þnvarsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnvarsþ"></A>
 <I></I>
<B>int þnvarsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnvarsþ"></A>
 <I></I>
<B>int þnvarsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnvarsþsize of the support of f"></A>
 <I></I>
<B>int þnvarsþsize of the support of f</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnzþ"></A>
 <I></I>
<B>int þnzþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnzþ"></A>
 <I></I>
<B>int þnzþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnzþ"></A>
 <I></I>
<B>int þnzþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþ"></A>
 <I></I>
<B>int þnþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþlength of both arrays"></A>
 <I></I>
<B>int þnþlength of both arrays</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþnumbers of unknowns"></A>
 <I></I>
<B>int þnþnumbers of unknowns</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþnumbers of unknowns"></A>
 <I></I>
<B>int þnþnumbers of unknowns</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþsize of <code>vars</code>"></A>
 <I></I>
<B>int þnþsize of <code>vars</code></B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþsize of the array"></A>
 <I></I>
<B>int þnþsize of the array</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþsize of the array"></A>
 <I></I>
<B>int þnþsize of the array</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þnþsize of the array"></A>
 <I></I>
<B>int þnþsize of the array</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þpairIndexþcorresponding variable index"></A>
 <I></I>
<B>int þpairIndexþcorresponding variable index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þpathþ"></A>
 <I></I>
<B>int þpathþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þphaseþ"></A>
 <I></I>
<B>int þphaseþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þphaseþ1: positive; 0: negative"></A>
 <I></I>
<B>int þphaseþ1: positive; 0: negative</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þpopulationSizeþ"></A>
 <I></I>
<B>int þpopulationSizeþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þpowerþ"></A>
 <I></I>
<B>int þpowerþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þprecisionþ"></A>
 <I></I>
<B>int þprecisionþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þprecisionþ"></A>
 <I></I>
<B>int þprecisionþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þprþ"></A>
 <I></I>
<B>int þprþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þprþ"></A>
 <I></I>
<B>int þprþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þprþverbosity level"></A>
 <I></I>
<B>int þprþverbosity level</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þprþverbosity level"></A>
 <I></I>
<B>int þprþverbosity level</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þrecombþ"></A>
 <I></I>
<B>int þrecombþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þsmsþ"></A>
 <I></I>
<B>int þsmsþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þsmvþ"></A>
 <I></I>
<B>int þsmvþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þsymmviolationþ"></A>
 <I></I>
<B>int þsymmviolationþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þsyþstep of column variables"></A>
 <I></I>
<B>int þsyþstep of column variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þsyþstep of column variables"></A>
 <I></I>
<B>int þsyþstep of column variables</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þthresholdþmaximum number of nodes in the subset"></A>
 <I></I>
<B>int þthresholdþmaximum number of nodes in the subset</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þthresholdþmaximum number of nodes in the subset"></A>
 <I></I>
<B>int þthresholdþmaximum number of nodes in the subset</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þthresholdþmaximum number of nodes in the superset"></A>
 <I></I>
<B>int þthresholdþmaximum number of nodes in the superset</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þthresholdþmaximum number of nodes in the superset"></A>
 <I></I>
<B>int þthresholdþmaximum number of nodes in the superset</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þtopþindex of top variable"></A>
 <I></I>
<B>int þtopþindex of top variable</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þupperBoundþdistance above which an approximate answer is OK"></A>
 <I></I>
<B>int þupperBoundþdistance above which an approximate answer is OK</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þupperþ"></A>
 <I></I>
<B>int þupperþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þupperþ"></A>
 <I></I>
<B>int þupperþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þvarþ"></A>
 <I></I>
<B>int þvarþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þvarþ"></A>
 <I></I>
<B>int þvarþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þvarþ"></A>
 <I></I>
<B>int þvarþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þvþ"></A>
 <I></I>
<B>int þvþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þvþ"></A>
 <I></I>
<B>int þvþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þxþ"></A>
 <I></I>
<B>int þxþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="int þyþcolumn index"></A>
 <I></I>
<B>int þyþcolumn index</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="largest"></A>
static int <I></I>
<B>largest</B>(
   <b></b> <i></i>
)
</pre>
<dd> Finds the largest DD in the population. If an order is
  repeated, it avoids choosing the copy that is in the computed table
  (it has repeat[i
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="long þseedþ"></A>
 <I></I>
<B>long þseedþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="long þsizeþsize of the allocation that failed"></A>
 <I></I>
<B>long þsizeþsize of the allocation that failed</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="make_random"></A>
static int <I></I>
<B>make_random</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b> <i></i>
)
</pre>
<dd> Generates the random sequences for the initial population.
  The sequences are permutations of the indices between lower and
  upper in the current order.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="mintermsFromUniverse"></A>
static DdNode * <I></I>
<B>mintermsFromUniverse</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode ** <b>vars</b>, <i></i>
  int  <b>numVars</b>, <i></i>
  double  <b>n</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Recursive procedure to extract n mintems from constant 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="oneliteralp"></A>
static int <I></I>
<B>oneliteralp</B>(
  DdHalfWord  <b>var</b> <i></i>
)
</pre>
<dd> Returns true iff the argument is a one-literal clause.
  A one-litaral clause has the constant FALSE as second literal.
  Since the constant TRUE is never used, it is sufficient to test for
  a constant.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="pushDown"></A>
static void <I></I>
<B>pushDown</B>(
  DdHalfWord * <b>order</b>, <i></i>
  int  <b>j</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Pushes a variable in the order down to position "level."
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="rand_int"></A>
static int <I></I>
<B>rand_int</B>(
  int  <b>a</b> <i></i>
)
</pre>
<dd> Generates a random number between 0 and the integer a.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="random_generator"></A>
static double <I></I>
<B>random_generator</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns a double precision value between 0.0 and 1.0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="restoreOrder"></A>
static int <I></I>
<B>restoreOrder</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Restores the variable order in array by a series of sifts up.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="roulette"></A>
static int <I></I>
<B>roulette</B>(
  int * <b>p1</b>, <i></i>
  int * <b>p2</b> <i></i>
)
</pre>
<dd> Selects two distinct parents with the roulette wheel method.
<p>

<dd> <b>Side Effects</b> The indices of the selected parents are returned as side
  effects.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="selectMintermsFromUniverse"></A>
static DdNode * <I></I>
<B>selectMintermsFromUniverse</B>(
  DdManager * <b>manager</b>, <i></i>
  int * <b>varSeen</b>, <i></i>
  double  <b>n</b> <i></i>
)
</pre>
<dd> This function prepares an array of variables which have not been
  encountered so far when traversing the procedure cuddSplitSetRecur. This
  array is then used to extract the required number of minterms from a constant
  1. The algorithm guarantees that the size of BDD will be utmost log(n).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="sentinelp"></A>
static int <I></I>
<B>sentinelp</B>(
  DdHalfWord  <b>var1</b>, <i></i>
  DdHalfWord  <b>var2</b> <i></i>
)
</pre>
<dd> Returns true iff the argument is the sentinel clause.
  A sentinel clause has both variables equal to 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="separateCube"></A>
static DdNode * <I></I>
<B>separateCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE * <b>distance</b> <i></i>
)
</pre>
<dd> Separates cube from distance.  Returns the cube if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The distance is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddClosestCube">cuddBddClosestCube</a>
<a href="#createResult">createResult</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="siftBackwardProb"></A>
static int <I></I>
<B>siftBackwardProb</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> Otherwise, "tosses a coin" to decide whether to keep
  the current configuration or return the DD to the original
  one. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="sift_up"></A>
static int <I></I>
<B>sift_up</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b> <i></i>
)
</pre>
<dd> Takes a variable from position x and sifts it up to
  position x_low;  x_low should be less than x. Returns 1 if successful;
  0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="stPathTableDdFree"></A>
static enum st_retval <I></I>
<B>stPathTableDdFree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> None
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="st_zdd_count_dbl_free"></A>
static enum st_retval <I></I>
<B>st_zdd_count_dbl_free</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory associated with the computed table of
  Cudd_zddCountDouble.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="st_zdd_countfree"></A>
static enum st_retval <I></I>
<B>st_zdd_countfree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory associated with the computed table of
  Cudd_zddCount.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="stopping_criterion"></A>
static int <I></I>
<B>stopping_criterion</B>(
  int  <b>c1</b>, <i></i>
  int  <b>c2</b>, <i></i>
  int  <b>c3</b>, <i></i>
  int  <b>c4</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> If temperature is STOP_TEMP or there is no improvement
  then terminates. Returns 1 if the termination criterion is met; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="tlcInfoAlloc"></A>
static DdTlcInfo * <I></I>
<B>tlcInfoAlloc</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns a pointer to a DdTlcInfo Structure if successful;
  NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_tlcInfoFree">Cudd_tlcInfoFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="unsigned int þfactorþ"></A>
 <I></I>
<B>unsigned int þfactorþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þhrþ"></A>
 <I></I>
<B>unsigned int þhrþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlimitþ"></A>
 <I></I>
<B>unsigned int þlimitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlimitþ"></A>
 <I></I>
<B>unsigned int þlimitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlimitþ"></A>
 <I></I>
<B>unsigned int þlimitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlimitþ"></A>
 <I></I>
<B>unsigned int þlimitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlimitþ"></A>
 <I></I>
<B>unsigned int þlimitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlimitþ"></A>
 <I></I>
<B>unsigned int þlimitþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þlutþ"></A>
 <I></I>
<B>unsigned int þlutþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þmaxLiveþ"></A>
 <I></I>
<B>unsigned int þmaxLiveþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þmcþ"></A>
 <I></I>
<B>unsigned int þmcþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þmrþ"></A>
 <I></I>
<B>unsigned int þmrþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þnextþ"></A>
 <I></I>
<B>unsigned int þnextþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þpþ"></A>
 <I></I>
<B>unsigned int þpþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þsecondDenþ"></A>
 <I></I>
<B>unsigned int þsecondDenþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þtypeþMTR_DEFAULT or MTR_FIXED"></A>
 <I></I>
<B>unsigned int þtypeþMTR_DEFAULT or MTR_FIXED</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þtypeþMTR_DEFAULT or MTR_FIXED"></A>
 <I></I>
<B>unsigned int þtypeþMTR_DEFAULT or MTR_FIXED</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned int þupperBþupper bound"></A>
 <I></I>
<B>unsigned int þupperBþupper bound</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned long þincreaseþ"></A>
 <I></I>
<B>unsigned long þincreaseþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned long þmaxMemoryþ"></A>
 <I></I>
<B>unsigned long þmaxMemoryþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned long þmaxMemoryþtarget maximum memory occupation"></A>
 <I></I>
<B>unsigned long þmaxMemoryþtarget maximum memory occupation</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned long þstþ"></A>
 <I></I>
<B>unsigned long þstþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="unsigned long þtlþ"></A>
 <I></I>
<B>unsigned long þtlþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="updateEntry"></A>
static int <I></I>
<B>updateEntry</B>(
  DdManager * <b>table</b>, <i></i>
  DdHalfWord * <b>order</b>, <i></i>
  int  <b>level</b>, <i></i>
  int  <b>cost</b>, <i></i>
  DdHalfWord ** <b>orders</b>, <i></i>
  int * <b>costs</b>, <i></i>
  int  <b>subsets</b>, <i></i>
  char * <b>mask</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Updates entry for a subset. Finds the subset, if it exists.
  If the new order for the subset has lower cost, or if the subset did not
  exist, it stores the new order and cost. Returns the number of subsets
  currently in the table.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="updateParity"></A>
static void <I></I>
<B>updateParity</B>(
  DdNode * <b>node</b>, <i>function to analyze</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>newparity</b> <i>new parity for node</i>
)
</pre>
<dd> Recursively update the parity of the paths reaching a node.
  Assumes that node is regular and propagates the invariant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#gatherInfoAux">gatherInfoAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="updateRefs"></A>
static int <I></I>
<B>updateRefs</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>skip</b>, <i></i>
  ApproxInfo * <b>info</b>, <i></i>
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Update function reference counts to account for replacement.
  Returns the number of nodes saved if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>UAmarkNodes
RAmarkNodes
BAmarkNodes
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="updateUB"></A>
static int <I></I>
<B>updateUB</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>oldBound</b>, <i></i>
  DdHalfWord * <b>bestOrder</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Updates the upper bound and saves the best order seen so far.
  Returns the current value of the upper bound.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="void *þdataþ"></A>
 <I></I>
<B>void *þdataþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="void *þdataþ"></A>
 <I></I>
<B>void *þdataþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="void *þdataþ"></A>
 <I></I>
<B>void *þdataþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME="zddClearFlag"></A>
static void <I></I>
<B>zddClearFlag</B>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs a DFS from f, clearing the LSB of the next
  pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#zddSupportStep">zddSupportStep</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="zddCountInternalMtrNodes"></A>
static int <I></I>
<B>zddCountInternalMtrNodes</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Counts the number of internal nodes of the group tree.
  Returns the count.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddFindNodeHiLo"></A>
static void <I></I>
<B>zddFindNodeHiLo</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>lower</b>, <i></i>
  int * <b>upper</b> <i></i>
)
</pre>
<dd> Finds the lower and upper bounds of the group represented
  by treenode.  The high and low fields of treenode are indices.  From
  those we need to derive the current positions, and find maximum and
  minimum.
<p>

<dd> <b>Side Effects</b> The bounds are returned as side effects.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddFixTree"></A>
static void <I></I>
<B>zddFixTree</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Fixes the ZDD variable group tree after a
  shuffle. Assumes that the order of the variables in a terminal node
  has not been changed.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddGroupMoveBackward"></A>
static int <I></I>
<B>zddGroupMoveBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap two groups.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupMove"></A>
static int <I></I>
<B>zddGroupMove</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups and records the move. Returns the
  number of keys in the DD table in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingAux"></A>
static int <I></I>
<B>zddGroupSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Sifts one variable up and down until it has taken all
  positions. Checks for aggregation. There may be at most two sweeps,
  even if the group grows.  Assumes that x is either an isolated
  variable, or it is the bottom of a group. All groups may not have
  been found. The variable being moved is returned to the best position
  seen during sifting.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingBackward"></A>
static int <I></I>
<B>zddGroupSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Determines the best position for a variables and returns
  it there.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingDown"></A>
static int <I></I>
<B>zddGroupSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts down a variable until it reaches position xHigh.
  Assumes that x is the bottom of a group (or a singleton).  Records
  all the moves.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingUp"></A>
static int <I></I>
<B>zddGroupSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts up a variable until either it reaches position
  xLow or the size of the DD heap increases too much. Assumes that y is
  the top of a group (or a singleton).  Checks y for aggregation to the
  adjacent variables. Records all the moves that are appended to the
  list of moves received as input and returned as a side effect.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSifting"></A>
static int <I></I>
<B>zddGroupSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Sifts from treenode->low to treenode->high. If
  croupcheck == CUDD_GROUP_CHECK7, it checks for group creation at the
  end of the initial sifting. If a group is created, it is then sifted
  again. After sifting one variable, the group that contains it is
  dissolved.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddMergeGroups"></A>
static void <I></I>
<B>zddMergeGroups</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Creates a single group from low to high and adjusts the
  idex field of the tree node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddPortFromBddStep"></A>
static DdNode * <I></I>
<B>zddPortFromBddStep</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  int  <b>expected</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPortFromBdd.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddPort.c"TARGET="ABSTRACT"><CODE>cuddZddPort.c</CODE></A>

<dt><pre>
<A NAME="zddPortToBddStep"></A>
static DdNode * <I></I>
<B>zddPortToBddStep</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>ZDD to be converted</i>
  int  <b>depth</b> <i>recursion depth</i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPortToBdd.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddPort.c"TARGET="ABSTRACT"><CODE>cuddZddPort.c</CODE></A>

<dt><pre>
<A NAME="zddPrintCoverAux"></A>
static void <I></I>
<B>zddPrintCoverAux</B>(
  DdManager * <b>zdd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int  <b>level</b>, <i>depth in the recursion</i>
  int * <b>list</b> <i>current recursion path</i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPrintCover.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="zddReorderChildren"></A>
static int <I></I>
<B>zddReorderChildren</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Reorders the children of a group tree node according to
  the options. After reordering puts all the variables in the group
  and/or its descendents in a single group. This allows hierarchical
  reordering.  If the variables in the group do not exist yet, simply
  does nothing. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddReorderPostprocess"></A>
static int <I></I>
<B>zddReorderPostprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Shrinks almost empty subtables at the end of reordering to
  guarantee that they have a reasonable load factor. However, if there many
  nodes are being reclaimed, then no resizing occurs. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddReorderPreprocess"></A>
static void <I></I>
<B>zddReorderPreprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prepares the ZDD heap for dynamic reordering. Does
  garbage collection, to guarantee that there are no dead nodes;
  and clears the cache, which is invalidated by dynamic reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddShuffle"></A>
static int <I></I>
<B>zddShuffle</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>permutation</b> <i></i>
)
</pre>
<dd> Reorders ZDD variables according to a given permutation.
  The i-th permutation array contains the index of the variable that
  should be brought to the i-th level. zddShuffle assumes that no
  dead nodes are present.  The reordering is achieved by a series of
  upward sifts.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddSiftUp"></A>
static int <I></I>
<B>zddSiftUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Takes a ZDD variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.
  Returns 1 if successful; 0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddSupportStep"></A>
static void <I></I>
<B>zddSupportStep</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>support</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddSupport. Performs a
  DFS from f. The support is accumulated in supp as a side effect. Uses
  the LSB of the then pointer as visited flag.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#zddClearFlag">zddClearFlag</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="zddSwapAny"></A>
static Move * <I></I>
<B>zddSwapAny</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps any two variables. Returns the set of moves.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddTreeSiftingAux"></A>
static int <I></I>
<B>zddTreeSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Recursively visits the group tree and reorders each
  group in postorder fashion.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddUniqueCompareGroup"></A>
static int <I></I>
<B>zddUniqueCompareGroup</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.  Returns the
  difference in number of keys between the two variables being
  compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddVarToConst"></A>
static void <I></I>
<B>zddVarToConst</B>(
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  DdNode * <b>base</b>, <i></i>
  DdNode * <b>empty</b> <i></i>
)
</pre>
<dd> Replaces variables with constants if possible (part of
  canonical form).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="zdd_group_move_backward"></A>
static int <I></I>
<B>zdd_group_move_backward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap of two groups. x is assumed to be the
  bottom variable of the first group. y is assumed to be the top
  variable of the second group.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="zdd_group_move"></A>
static int <I></I>
<B>zdd_group_move</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups. x is assumed to be the bottom variable
  of the first group. y is assumed to be the top variable of the second
  group.  Updates the list of moves. Returns the number of keys in the
  table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="zdd_print_minterm_aux"></A>
static void <I></I>
<B>zdd_print_minterm_aux</B>(
  DdManager * <b>zdd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int  <b>level</b>, <i>depth in the recursion</i>
  int * <b>list</b> <i>current recursion path</i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPrintMinterm.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="zdd_subset0_aux"></A>
static DdNode * <I></I>
<B>zdd_subset0_aux</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddSubset0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="zdd_subset1_aux"></A>
static DdNode * <I></I>
<B>zdd_subset1_aux</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddSubset1.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="zp2"></A>
static int <I></I>
<B>zp2</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>t</b> <i></i>
)
</pre>
<dd> Performs the recursive step of cuddZddP. Returns 1 in
  case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="þþ"></A>
 <I></I>
<B>þþ</B>(
   <b></b> <i></i>
)
</pre>
<dd> 
<p>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Adds node to the head of the free list.  Does not
  deallocate memory chunks that become free.  This function is also
  used by the dynamic reordering functions.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAllocNode">cuddAllocNode</a>
<a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
<a href="#cuddDeallocMove">cuddDeallocMove</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Adds node to the head of the free list.  Does not
  deallocate memory chunks that become free.  This function is also
  used by the dynamic reordering functions.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddDeallocNode">cuddDeallocNode</a>
<a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Adjusts the values of table fields controlling the.
  sizes of subtables and computed table. If the computed table is too small
  according to the new values, it is resized.
<p>

<dd> <b>Side Effects</b> Modifies manager fields. May resize computed table.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Clears a bit vector.  The parameter size gives the
  number of bits.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorAlloc">bitVectorAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Clears the 4 least significant bits of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Comparison of a function to the i-th ADD variable. Returns 1 if
  the function is the i-th ADD variable; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Comparison of a pair of functions to the i-th ADD
  variable. Returns 1 if the functions are the i-th ADD variable and its
  complement; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Complements a DD if condition c is true; c should be
  either 0 or 1, because it is used directly (for efficiency). If in
  doubt on the values c may take, use "(c) ? Cudd_Not(node) : node".
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Not">Cudd_Not</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Complements a DD by flipping the complement attribute of
  the pointer (the least significant bit).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_NotCond">Cudd_NotCond</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes hash function for keys of one operand.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddLCHash3">ddLCHash3</a>
<a href="#ddLCHash">ddLCHash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes hash function for keys of three operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddLCHash2">ddLCHash2</a>
<a href="#ddLCHash">ddLCHash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes hash function for keys of two operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddLCHash3">ddLCHash3</a>
<a href="#ddLCHash">ddLCHash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the absolute value of a number.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the hash value for a local cache. Returns the
  bucket index.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the maximum of two numbers.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddMin">ddMin</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the minimum of two numbers.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddMax">ddMax</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Decreases the reference count of node. It is primarily
  used in recursive procedures to decrease the ref count of a result
  node before returning it. This accomplishes the goal of removing the
  protection applied by a previous cuddRef. This being a macro, it is
  faster than Cudd_Deref, but it cannot be used in constructs like
  cuddDeref(a = b()).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Deref">Cudd_Deref</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Enforces DD_MINUS_INF_VAL <= x <= DD_PLUS_INF_VAL.
  Furthermore, if x <= DD_MINUS_INF_VAL/2, x is set to
  DD_MINUS_INF_VAL. Similarly, if DD_PLUS_INF_VAL/2 <= x, x is set to
  DD_PLUS_INF_VAL.  Normally this macro is a NOOP. However, if
  HAVE_IEEE_754 is not defined, it makes sure that a value does not
  get larger than infinity in absolute value, and once it gets to
  infinity, stays there.  If the value overflows before this macro is
  applied, no recovery is possible.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Extract the least significant digit of a double digit. Used
  in the manipulation of arbitrary precision integers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>DD_MSDIGIT
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Extract the most significant digit of a double digit. Used
  in the manipulation of arbitrary precision integers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>DD_LSDIGIT
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Fast storage allocation for items in a hash table. The
  first 4 bytes of a chunk contain a pointer to the next block; the
  rest contains DD_MEM_CHUNK spaces for hash items.  Returns a pointer to
  a new item if successful; NULL is memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAllocNode">cuddAllocNode</a>
<a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Finds the current position of ZDD variable index in the
  order.  This macro duplicates the functionality of Cudd_ReadPermZdd,
  but it does not check for out-of-bounds indices and it is more
  efficient.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPermZdd">Cudd_ReadPermZdd</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Finds the current position of variable index in the
  order.  This macro duplicates the functionality of Cudd_ReadPerm,
  but it does not check for out-of-bounds indices and it is more
  efficient.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the cache for functions with two
  operands.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddHash">ddHash</a>
<a href="#ddCHash">ddCHash</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the cache.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddHash">ddHash</a>
<a href="#ddCHash2">ddCHash2</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the table of a level queue.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#hashInsert">hashInsert</a>
<a href="#hashLookup">hashLookup</a>
<a href="#hashDelete">hashDelete</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the unique table.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddCHash">ddCHash</a>
<a href="#ddCHash2">ddCHash2</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Increases the reference count of a node, if it is not
  saturated. This being a macro, it is faster than Cudd_Ref, but it
  cannot be used in constructs like cuddRef(a = b()).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Ref">Cudd_Ref</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the cubes of a decision diagram f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> int *cube;
  <li> CUDD_VALUE_TYPE value;
  </ul>
  Cudd_ForeachCube allocates and frees the generator. Therefore the
  application should not try to do that. Also, the cube is freed at the
  end of Cudd_ForeachCube and hence is not available outside of the loop.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure
  that dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur. Alternatively, it is sufficient to
  disable dynamic reordering. It is a mistake to dispose of a diagram
  on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the nodes of a decision diagram f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> DdNode *node;
  </ul>
  The nodes are returned in a seemingly random order.
  Cudd_ForeachNode allocates and frees the generator. Therefore the
  application should not try to do that.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure
  that dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur. Alternatively, it is sufficient to
  disable dynamic reordering. It is a mistake to dispose of a diagram
  on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the paths of a ZDD f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> int *path;
  </ul>
  Cudd_zddForeachPath allocates and frees the generator. Therefore the
  application should not try to do that. Also, the path is freed at the
  end of Cudd_zddForeachPath and hence is not available outside of the loop.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators.  It is the user's responsibility to make sure
  that dynamic reordering does not occur.  As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur.  Alternatively, it is sufficient to
  disable dynamic reordering.  It is a mistake to dispose of a diagram
  on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddFirstPath">Cudd_zddFirstPath</a>
<a href="#Cudd_zddNextPath">Cudd_zddNextPath</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the primes of a Boolean function producing
  a prime and irredundant cover.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *l;
  <li> DdNode *u;
  <li> DdGen *gen;
  <li> int *cube;
  </ul>
  The Boolean function is described by an upper bound and a lower bound.  If
  the function is completely specified, the two bounds coincide.
  Cudd_ForeachPrime allocates and frees the generator.  Therefore the
  application should not try to do that.  Also, the cube is freed at the
  end of Cudd_ForeachPrime and hence is not available outside of the loop.<p>
  CAUTION: It is a mistake to change a diagram on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_FirstPrime">Cudd_FirstPrime</a>
<a href="#Cudd_NextPrime">Cudd_NextPrime</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Outputs a line of stats if DD_COUNT and DD_STATS are
  defined. Increments the number of recursive calls if DD_COUNT is
  defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Performs the left rotation for red/black trees.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRotateRight">cuddRotateRight</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Performs the right rotation for red/black trees.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRotateLeft">cuddRotateLeft</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if a pointer is complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Regular">Cudd_Regular</a>
<a href="#Cudd_Complement">Cudd_Complement</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if the absolute value of the difference of the two
  arguments x and y is less than e.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if the node is a constant node (rather than an
  internal node). All constant nodes have the same index
  (CUDD_CONST_INDEX). The pointer passed to Cudd_IsConstant may be either
  regular or complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if the node is a constant node (rather than an
  internal node). All constant nodes have the same index
  (CUDD_CONST_INDEX). The pointer passed to cuddIsConstant must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_IsConstant">Cudd_IsConstant</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the arithmetic 0 constant node. This is different
  from the logical zero. The latter is obtained by
  Cudd_Not(DD_ONE(dd)).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
<a href="#Cudd_Not">Cudd_Not</a>
DD_PLUS_INFINITY
DD_MINUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the average fitness of the population.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the complemented version of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Regular">Cudd_Regular</a>
<a href="#Cudd_IsComplement">Cudd_IsComplement</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the constant 1 node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ZERO
DD_PLUS_INFINITY
DD_MINUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the current position in the order of variable
  index. This macro is obsolete and is kept for compatibility. New
  applications should use Cudd_ReadPerm instead.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the else child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
  The pointer passed to cuddE must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_E">Cudd_E</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the else child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_T">Cudd_T</a>
<a href="#Cudd_V">Cudd_V</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the i-th entry of a bit vector.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorSet">bitVectorSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the minus infinity constant node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
DD_ZERO
DD_PLUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the plus infinity constant node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
DD_ZERO
DD_MINUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the regular version of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Complement">Cudd_Complement</a>
<a href="#Cudd_IsComplement">Cudd_IsComplement</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the then child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
  The pointer passed to cuddT must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_T">Cudd_T</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the then child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_E">Cudd_E</a>
<a href="#Cudd_V">Cudd_V</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the value of a constant node. If
  <code>node</code> is an internal node, the result is unpredictable.
  The pointer passed to cuddV must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_V">Cudd_V</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the value of a constant node. If
  <code>node</code> is an internal node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_T">Cudd_T</a>
<a href="#Cudd_E">Cudd_E</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Saturating decrement operator.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#cuddSatInc">cuddSatInc</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Saturating increment operator.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#cuddSatDec">cuddSatDec</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Sets the i-th entry of a bit vector to a value.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorRead">bitVectorRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>


</DL>
<HR>
Last updated on 20120204 17h33
</BODY></HTML>
