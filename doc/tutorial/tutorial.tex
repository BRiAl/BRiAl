%
%  untitled
%
%  Created by Michael Brickenstein on 2007-11-08.
%  Copyright (c) 2007 Mathematisches Forschungsinstitut Oberwolfach. All rights reserved.
%
\documentclass[]{article}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}

% Multipart figures
%\usepackage{subfigure}

% More symbols
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{latexsym}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}
\usepackage{xspace}
% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}
\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi
\newenvironment{code}{\begin{verbatim}}{\end{verbatim}}
\newcommand{\PolyBoRi}{{\sc PolyBoRi}\xspace}
\newcommand{\CUDD}{{CUDD}\xspace}
\newcommand{\ite}{{ite}\xspace}
\providecommand{\boolemult}{\ensuremath{{\star\hspace{-.15em}_2\hspace{.05em}}}\xspace}
%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi


\title{\PolyBoRi tutorial}
\author{Michael Brickenstein  }




\date{2007-11-08}

\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle
\newcommand{\Singular}{{\sc Singular}}

\begin{abstract}
\end{abstract}

\section{Introduction}
\subsection{Interfaces}
The core of \PolyBoRi is a C++ library. On top of it there exists a Python interface.
Additionally to the Python interface a integration into SAGE was provided by Burcin Erocal.
The main difference is, that the Python interface makes use of the boost library, while the SAGE interface relies on Cython.
However the wrappers for SAGE and the original Python interface are designed, that it is possible to run the same code under both bindings.

We provide an interactive shell for \PolyBoRi using ipython (either using sage or ipbori).
In ipbori a global ring is predefined and a set of variables called  $x(0), \ldots, x(9999)$. The default ordering is lexicographical ordering (lp).
\subsection{Ordering}
The monomial ordering can be changed by calling
change\_ordering(Ordering.code), where code can be either lp (lexicographical ordering), dlex (degree lexicographical ordering), dp\_asc (degree reverse lexicographical ordering with ascending variable ordering), block\_dlex, block\_dp\_asc (for odering composed out of blocks in the corresponding ordering). When using block ordering, after changing to that ordering, blocks have to be defined using the append\_ring\_block function.

In contrast to the lexicographical, degree lexicographical ordering, and the degree reverse lexicographical ordering in \Singular, our degree reverse lexicographical ordering has a reverse variable order (the first ring variable is smaller than the second, the second smaller than the third). This is a result of the fact, that efficient implementation of monomial orderings using ZDD structures is quite difficult (and the performance depends on the ordering).


Example:
\begin{verbatim}
r=Ring(1000)
change_ordering(block_dp_asc)
append_ring_block(10)
append_ring_block(20)
\end{verbatim}
In this example, we have an ordering composed of three blocks, the first with ten variables, the second contains the $x(10), \ldots x(19)$ (per default indices start at 0).
\subsection{Arithmetic}
Basic arithmetic is provided in the domain of Boolean polynomials. If exponents bigger than one appear in a variable reduction by the field ideal is done automatically.
\begin{verbatim}
In [1]: (x(1)+x(2))*(x(1)+x(3))
Out[1]: x(1)*x(2) + x(1)*x(3) + x(1) + x(2)*x(3)
\end{verbatim}
\subsection{Gröbner bases}
Gröbner bases functionality is available using the function groebner\_basis from polybori.gbcore.
It has quite a lot of options and a exchangable heuristic.
There exist in principle default values, but if the option is not provided explicitely, the heuristic function
may decide dynamically by taking the ideal, the ordering and the other options into account, which is the best configuration.
\begin{verbatim}
In [1]: groebner_basis([x(1)+x(2),(x(2)+x(1)+1)*x(3)])
Out[1]: [x(1) + x(2), x(3)]

\end{verbatim}
\section{How to program efficiently}
The goal of this section is to explain how to get most performance out of \PolyBoRi using the underlying ZDD structure.
This awareness can be seen on several levels
\begin{itemize}
    \item ZDD unaware, pure algebraic programming 
    \item low level friendly programming
    \item replacing algebraic operations by (a composition of) set operations
    \item Cudd recursive programming without caching
    \item Cudd recursive programming with caching
    \item using ZDDs for many other things than polynomial arithmetics
\end{itemize}
\subsection{Low level friendly programming}
\label{low-level-friendly}
\PolyBoRi is implemented as layer over a decision diagram library (\CUDD at the moment).

In \CUDD every diagram node is unique: If two diagrams have the same structure, the are in fact identical (same position in memory).
Another observation is, that \CUDD tries to build a functional style API in the C programming language. This means, that no data is manipulated, only new nodes are created.
Functional programming is in principal very suited for caching and multithreading (at the moment however threading is not possible).
The \ite-operator is the most central function in CUDD. It takes two nodes/diagrams $t$, $e$ and an index $i$ and creates a diagram with root variable $i$ and
then-branch $t$, else-branch $e$. It is necessary that the branches have root variables with bigger index (or are constant).
It creates either exactly one node, or retrieves the correct node from the cache.
Function calls which come essentially down to a single \ite call are very cheap.
For example taking the product $x_1 \boolemult (x_2\boolemult(x3\boolemult (x_4\boolemult x_5)))$ is much cheaper than $((((x_1 \boolemult x_2)\boolemult x3)\boolemult x_4)\boolemult x_5)$.
In the first case, in each step a single not is prepended to the diagram, while in the second case, a completely new diagram is created.
The same argumemt would apply for the addition of these variables.
This example shows, that having a little bit background about the data structure, it is often possible to write code, that looks as well algebraic as provides good performance.

\subsection{Replace algebra by set operations}
Often there is an alternativ description in terms of set operations for algebraic operations, which is much faster.

\subsection{Construct power sets}
An example for this behaviour is the calculation of power sets (sets of monomials/polynomials containing each term in the specified variables).
The following code constructs such a power set very inefficiently for the first free variables:
\begin{verbatim}
sum([x(1)**i1*x(2)**i2*x(3)**i3 for i1 in (0,1) for i2 in (0,1) for i3 in (0,1)])
\end{verbatim}
The algorithm has of course exponential complexity in the number of variables.
The resulting ZDD however has as many nodes as variables.
In fact it can be constructed directly using the following function (from specialsets.py).
\begin{verbatim}
def power_set(variable_indices):
    variable_indices=list(reversed(list(set(variable_indices))))
    res=Polynomial(1).set()
    for v in variable_indices:
        res=if_then_else(v,res,res)
    return res
\end{verbatim}
Note, that we switched from polynomials to diagrams. We inverse the order of variable indices for iteration to make the computation compatible with the principles in \ref{low-level-friendly} (simple \ite operators instead of complex operations in each step).
\subsection{All monomials of degree d}
\begin{verbatim}
def all_monomials_of_degree_d(d,variable_indices):
    if d == 0:
        return Polynomial(1).set()
    if len(variable_indices) == 0:
        return BooleSet()
    variable_indices = list(reversed(list(set(variable_indices))))
    m = Variable(variable_indices[-1])
    for v in variable_indices[:-1]:
        m = Variable(v) + m
    m = m.set()
    def do_all_monomials(d):
        if d == 0:
            return Polynomial(1).set()
        else:
            prev = do_all_monomials(d-1)
            return prev.cartesianProduct(m).diff(prev)
    return do_all_monomials(d)
\end{verbatim}
We use the set of all monomials of one degree lower using the cartesian product with the set of variables and remove every term, where the degree did not increase (boolean multiplication: $x^2=x$).

\section{Case study: Graded part of a polynomial}
In the following we will show five variants to implement a function, that computes the sum of all terms of degree $d$ in a polynomial $f$.
\subsection{Simple, algebraic solution}
\begin{verbatim}
def simple_graded(f, d):
    return sum((t for t in f if t.deg()==d))   
\end{verbatim}
The solution is obvious, but quite slow.
\subsection{Low level friendly, algebraic solution}
\begin{verbatim}
def friendly_graded(f, d):
    vec=BoolePolynomialVector()
    for t in f:
        if t.deg()!=d:
            continue
        else:
            vec.append(t)
    return add_up_polynomials(vec)
\end{verbatim}
We leave it to the heuristic of the add\_up\_polynomials function how to add up the monomials. For example a divide and conquer strategy is quite good here.
\subsection{Highlevel with set operations}
\begin{verbatim}
def highlevel_graded(f,d):
    return Polynomial(f.set().intersect(all_monomials_of_degree_d(d,f.vars())))
\end{verbatim}
This solution build on the fast intersection algorithm and decomposes the task in just two set operations, which is very good.

However it can be quite inefficient, when f has many variables.
This can increase the number of steps in the intersection algorithm (which takes with high probability the else branch of the second argument in each step).
\subsection{Recursive}
This unnecessary branches can be avoided by taking just integers as second argument for the recursive algorithm (in the last section this was `intersection').

\begin{verbatim}
def recursive_graded(f,d):
    def do_recursive_graded(f,d):
        if f.empty():
            return f
        if d==0:
            if Monomial() in f:
                return Polynomial(1).set()
            else:
                return BooleSet()
        else:
            nav=f.navigation()
            if nav.constant():
                return BooleSet()
            return if_then_else(
                nav.value(),
                do_recursive_graded(BooleSet(nav.thenBranch()),d-1),
                do_recursive_graded(BooleSet(nav.elseBranch()),d))
    return Polynomial(do_recursive_graded(f.set(),d))
        
\end{verbatim}
Recursive implementations are very compatible with our data structures, so are quite fast. However this implementation does not use any caching techniques. Cudd recursive caching requires functions to have one, two or three parameters, which are of ZDD structure (so no integers).
Of course we can encode the degree $d$ by the d-th Variable in the Polynomial ring.
\subsection{Cudd-recursive implementation in \PolyBoRi}
The C++ implementation of the functionality in \PolyBoRi is given in this section, which is recursive and uses caching techniques.
\begin{verbatim}
// determine the part of a polynomials of a given degree
template <class CacheType, class NaviType, class DegType, class SetType>
SetType
dd_graded_part(const CacheType& cache, NaviType navi, DegType deg,  
               SetType init) {


  if (deg == 0) {
    while(!navi.isConstant())
      navi.incrementElse();
    return SetType(navi);
  }

  if(navi.isConstant())
    return SetType();

  // Look whether result was cached before
  NaviType cached = cache.find(navi, deg);

  if (cached.isValid())
    return SetType(cached);

  SetType result = 
    SetType(*navi,  
            dd_graded_part(cache, navi.thenBranch(), deg - 1, init),
            dd_graded_part(cache, navi.elseBranch(), deg, init)
            );

  // store result for later reuse
  cache.insert(navi, deg, result.navigation());

  return result;
}
\end{verbatim}
The encoding of integers for the degree as variable is done implicitely by our cache lookup functions.

\bibliographystyle{plain}

\bibliography{}
\end{document}
